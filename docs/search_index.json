[["index.html", "Fission-fusion dynamics in B1 troop 本稿の目的", " Fission-fusion dynamics in B1 troop Tsubasa Yamaguchi 2024-10-22 本稿の目的 本稿では、博士論文の2つ目の論文となる群れ内の凝集性に関する分析を行います。分析に使用したコードはGitHubから確認できます。 "],["01_library.html", "0. パッケージの読み込み", " 0. パッケージの読み込み 本稿はRの基本操作とtidyverseパッケージによるデータハンドリングができることを前提としている。tidyverseパッケージを用いたデータ処理については、以下の書籍などを参照。 R for Data Science (Wickham &amp; Grolemund, 2016) 電子書籍, 日本語 R Graphics Coocbook 2nd Edition (Chang, 2018) 電子書籍, 日本語 RユーザのためのRstudio[実践]入門~tidyverseによるモダンな分析フローの世界 改訂2版 (松村 et al., 2021) 出版社サイト 使用するパッケージは以下のとおりである。 ## データハンドリング library(tidyverse) library(readxl) library(knitr) library(easystats) library(DT) library(scales) library(emmeans) library(tcltk) ## モデリング library(brms) library(glmmTMB) library(rethinking) library(rstan) library(rstanarm) library(cmdstanr) library(ggeffects) library(DHARMa) library(DHARMa.helpers) ## ネットワーク分析 library(sna) library(ANTs) library(asnipe) library(aninet) library(vegan) library(igraph) library(tidygraph) library(ggraph) ## グラフや表関連 library(ggtext) library(ggforce) library(ggbeeswarm) library(plotly) library(bayesplot) library(viridis) library(ggnewscale) library(GGally) library(flextable) library(ggrepel) library(patchwork) library(kableExtra) library(ggsci) library(lemon) library(ggsignif) library(ggh4x) library(ggrepel) library(ggpattern) # ## フォント関連 library(extrafont) require(systemfonts) # ベイズモデルの設定 rstan_options(auto_write = TRUE) options(mc.cores = parallel::detectCores()) References Chang, W. (2018). R graphics cookbook: Practical recipes for visualizing data. “O’Reilly Media, Inc.” Wickham, H., &amp; Grolemund, G. (2016). R for data science: Import, tidy, transform, visualize, and model data. “O’Reilly Media, Inc.” 松村優哉., 湯谷啓明., 紀ノ定保礼., &amp; 前田和. (2021). RユーザのためのRstudio[実践]入門 tidyverseによるモダンな分析フローの世界 改訂2版. 技術評論社. "],["02_Basicdata.html", "1 データの読み込み 1.1 Daily data の読み込み 1.2 個体追跡データの読み込み 1.3 群れの詳細な出欠データを読み込む 1.4 オスの攻撃データを読み込む", " 1 データの読み込み 以下、基本的なデータの読み込みを行う。なお、本論文で使用するのはた8つの期間（2018交尾期、2019非交尾期、2019交尾期、2020非交尾期、2020交尾期、2021非交尾期、2021交尾期、2022非交尾期）のデータである。 1.1 Daily data の読み込み 以下、日ベースのデータについてデータフレームを作成する。 なお、**には観察年の下2桁と交尾期(m)/非交尾期(nm)が入る。 base_**: 追跡時間や気温についての情報。 female_**: 各メスの確認の有無と発情の有無、年齢など（分派集団で確認された個体も含む） male_**: 各オスの確認の有無 female_all: 全期間をまとめたメスの確認状況 male_all: 全期間をまとめたオスの確認状況 1.2 個体追跡データの読み込み 以下では、個体追跡の生データとして、以下のデータシートを読み込む。 focal_18m: 2018年交尾期の個体追跡データ focal_19m: 2019年交尾期の個体追跡データ focal_20m: 2020年交尾期の個体追跡データ focal_21m: 2021年交尾期の個体追跡データ focal_19nm: 2019年非交尾期の個体追跡データ focal_21nm: 2021年非交尾期の個体追跡データ focal_22nm: 2022年非交尾期の個体追跡データ focal_combined: 全個体追跡データを結合したもの 1.3 群れの詳細な出欠データを読み込む 1日に2つ以上の集団を確認した日を含めて、群れ個体の詳細な出欠データを読み込む。 5歳以上のメスと群れオスの確認状況のデータが記録されている(2018年度は6歳以上のメス)。 以下のデータを読み込んで加工する。 なお、**には観察年の下2桁と交尾期(m)/非交尾期(nm)が入る。 group_**: 観察した各集団における個体の確認状況と観察時間 group_all: 全てのデータを結合 1.4 オスの攻撃データを読み込む 以下、全生起サンプリングによって収集した生データを読み込む。 agg_m**: 各交尾期のデータ aggression_all: 全交尾期のデータ "],["03_CSI_female.html", "2 メス同士のCSIの算出 2.1 CSIの定義 2.2 データの加工 2.3 CSIの算出(全期間) 2.4 CSIの算出(2018交尾期～2019交尾期) 2.5 CSIの算出(Tam生存前まで) 2.6 CSIの算出(調査期間ごと)", " 2 メス同士のCSIの算出 2.1 CSIの定義 ここでは、TYとのCSIを算出する。 CSIの算出式は以下の通り。なお、\\(i = 1,2,3,...,N\\)はメスのIDを表す。\\(P_i\\)の算出の際には互いに毛づくろいしているポイントは除いた。対象としたのは2018年時点で6歳以上だった非発情の個体である。 \\(G_{ij}\\): メスiとメスjの毛づくろい時間割合 (iとjが毛づくろいしたポイント数/iとj総ポイント数) \\(P_{i}\\): メスiとメスjの近接時間割合 (3m以内にいとjがいたポイント数/iまたはjが地上採食または休息したポイント数) \\(\\overline{G}: \\frac{1}{N} \\sum^{N}_{i=1}G_{i}\\) \\(\\overline{P}: \\frac{1}{N} \\sum^{N}_{i=1}P_{i}\\) \\[ CSI_{i} = \\frac{\\left(\\frac{G_{i}}{\\overline{G}} +\\frac{P_{i}}{\\overline{P}}\\right)}{2} \\;\\;(i = 1,2,\\dots,N) \\] 使用するのは2018年交尾期、2019年交尾期、2019年非交尾期、2021年非交尾期、2022年非交尾期のデータである。 2.2 データの加工 交尾期のデータについて、追跡個体が発情しているかの列を追加し、発情していない日のデータのみを抽出する(focal_18m_b、focal_19m_b)。 focal_18m %&gt;% left_join(female_18m %&gt;% rename(subject = femaleID) %&gt;% select(date, subject, rs2) , by = c(&quot;date&quot;, &quot;subject&quot;)) %&gt;% filter(rs2 == &quot;0&quot;) -&gt; focal_18m_b focal_19m %&gt;% left_join(female_19m %&gt;% rename(subject = femaleID) %&gt;% select(date, subject, rs2) , by = c(&quot;date&quot;, &quot;subject&quot;)) %&gt;% filter(rs2 == &quot;0&quot;) -&gt; focal_19m_b 2.3 CSIの算出(全期間) 算出するメスのIDは、全期間のデータがあった以下の通り。 femaleID &lt;- sort(c(&quot;Kil&quot;,&quot;Mik&quot;,&quot;Koh&quot;,&quot;Aka&quot;,&quot;Ten&quot;,&quot;Ntr&quot;,&quot;Hen&quot;,&quot;Hot&quot;,&quot;Tot&quot;,&quot;Mei&quot;,&quot;Ako&quot;,&quot;Kol&quot;,&quot;Mal&quot;,&quot;Kit&quot;,&quot;Kun&quot;)) 2.3.1 毛づくろい時間割合の算出 focal_all &lt;- bind_rows(focal_18m_b, focal_19m_b, focal_19nm, focal_21nm, focal_22nm) ## 毛づくろい相手を表す列を作成 focal_all %&gt;% mutate(groom = ifelse(groomer == subject,groomee,groomer), groom2 = ifelse(groomer2 == subject,groomee2,groomer2)) -&gt; focal_all_b 各メスの追跡時間(総瞬間サンプリングポイント数)を算出する。 focal_all_b %&gt;% filter(subject %in% femaleID) %&gt;% group_by(subject) %&gt;% summarise(dur = n()) -&gt; focal_duration 対象となるメスと毛づくろいしていたポイントを抽出する。 focal_all_b %&gt;% filter(activity == &quot;G&quot;) %&gt;% filter(subject %in% femaleID) %&gt;% select(date, no_focal, time, subject, groom, groom2) %&gt;% pivot_longer(cols = c(&quot;groom&quot;,&quot;groom2&quot;), names_to = &quot;groom&quot;, values_to = &quot;ID&quot;) %&gt;% filter(ID %in% femaleID) -&gt; groom_pairs 最後に、毛づくろい時間割合を算出してマトリックスにする。 groom_mat &lt;- df.to.mat(groom_pairs, actor = &quot;subject&quot;, receiver = &quot;ID&quot;, sym = T, tob = focal_duration$dur) 2.3.2 近接時間割合の算出 続いて、近接時間割合を算出する。なお、互いに毛づくろいをしていた時間は除く点は注意が必要である。 まず、地上採食・休息・毛づくろいのポイントのみを抽出する。 focal_all_b %&gt;% filter(activity %in% c(&quot;F&quot;,&quot;R&quot;,&quot;G&quot;) &amp; T_G == &quot;G&quot;) %&gt;% select(no_focal, subject, x0_1m:x1_3m, groom, groom2, study_period) %&gt;% replace_na(list(groom = &quot;NA&quot;, groom2 = &quot;NA&quot;)) -&gt; focal_prox 続いて、上記のうち各メス同士が毛づくろいをしていなかったポイント数を算出する(= 分母)。 prox_denom &lt;- matrix(nrow = length(femaleID), ncol = length(femaleID)) for(i in seq_along(femaleID)){ for(j in seq_along(femaleID)){ prox_denom[i,j] &lt;- focal_prox %&gt;% filter(subject == femaleID[i]) %&gt;% filter(groom != femaleID[j] &amp; groom2 != femaleID[j]) %&gt;% nrow() } } ## 転置行列と足す prox_denom2 &lt;- prox_denom + t(prox_denom) ## 対角成分は0にする diag(prox_denom2) &lt;- 0 rownames(prox_denom2) &lt;- femaleID colnames(prox_denom2) &lt;- femaleID 続いて、各メスが毛づくろいをしていなかったポイントのうち近接していたポイント数を算出する。 prox_numer &lt;- matrix(nrow = length(femaleID), ncol = length(femaleID)) for(i in seq_along(femaleID)){ for(j in seq_along(femaleID)){ prox_numer[i,j] &lt;- focal_prox %&gt;% filter(subject == femaleID[i]) %&gt;% filter(groom != femaleID[j] &amp; groom2 != femaleID[j]) %&gt;% filter(str_detect(x0_1m, femaleID[j])|str_detect(x1_3m, femaleID[j])) %&gt;% nrow() } } ## 転置行列と足す prox_numer2 &lt;- prox_numer + t(prox_numer) ## 対角成分は0にする rownames(prox_numer2) &lt;- femaleID colnames(prox_numer2) &lt;- femaleID 最後に、これらを基に近接時間割合を算出する。 prox_mat &lt;- prox_numer2/prox_denom2 diag(prox_mat) &lt;- 0 2.3.3 CSIの算出 最後に、CSIを算出する。ここでは、aninetパッケージのdyadic_csi()関数を用いる。 library(aninet) CSI_female &lt;- dyadic_csi(list(groom_mat, prox_mat)) colnames(CSI_female) &lt;- femaleID rownames(CSI_female) &lt;- femaleID CSIを図示すると以下のようになる。 CSI_female %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot;ID1&quot;) %&gt;% pivot_longer(2:16, names_to = &quot;ID2&quot;, values_to = &quot;CSI&quot;) %&gt;% ggplot(aes(x = ID1, y = ID2))+ geom_tile(aes(fill = CSI))+ scale_fill_gradient2(high = muted(&quot;blue&quot;), low = muted(&quot;red&quot;), mid = &quot;white&quot;, midpoint = 1)+ theme(aspect.ratio = 1)+ labs(x = &quot;&quot;, y = &quot;&quot;) 2.4 CSIの算出(2018交尾期～2019交尾期) 算出するメスのIDは、この期間のデータがあった以下の通り。 femaleID2 &lt;- sort(c(&quot;Kil&quot;,&quot;Mik&quot;,&quot;Koh&quot;,&quot;Aka&quot;,&quot;Tam&quot;,&quot;Ten&quot;,&quot;Ntr&quot;,&quot;Hen&quot;,&quot;Hot&quot;,&quot;Tot&quot;,&quot;Mei&quot;,&quot;Ako&quot;,&quot;Kol&quot;,&quot;Mal&quot;,&quot;Kit&quot;,&quot;Kun&quot;)) 2.4.1 毛づくろい時間割合の算出 focal_fh &lt;- bind_rows(focal_18m_b, focal_19m_b, focal_19nm) ## 毛づくろい相手を表す列を作成 focal_fh %&gt;% mutate(groom = ifelse(groomer == subject,groomee,groomer), groom2 = ifelse(groomer2 == subject,groomee2,groomer2)) -&gt; focal_fh_b 各メスの追跡時間(総瞬間サンプリングポイント数)を算出する。 focal_fh_b %&gt;% filter(subject %in% femaleID2) %&gt;% group_by(subject) %&gt;% summarise(dur = n()) -&gt; focal_duration_fh 対象となるメスと毛づくろいしていたポイントを抽出する。 focal_fh_b %&gt;% filter(activity == &quot;G&quot;) %&gt;% filter(subject %in% femaleID2) %&gt;% select(date, no_focal, time, subject, groom, groom2) %&gt;% pivot_longer(cols = c(&quot;groom&quot;,&quot;groom2&quot;), names_to = &quot;groom&quot;, values_to = &quot;ID&quot;) %&gt;% filter(ID %in% femaleID2) -&gt; groom_pairs_fh 最後に、毛づくろい時間割合を算出してマトリックスにする。 groom_mat_fh &lt;- df.to.mat(groom_pairs_fh, actor = &quot;subject&quot;, receiver = &quot;ID&quot;, sym = T, tob = focal_duration_fh$dur) 2.4.2 近接時間割合の算出 続いて、近接時間割合を算出する。なお、互いに毛づくろいをしていた時間は除く点は注意が必要である。 まず、地上採食・休息・毛づくろいのポイントのみを抽出する。 focal_fh_b %&gt;% filter(activity %in% c(&quot;F&quot;,&quot;R&quot;,&quot;G&quot;) &amp; T_G == &quot;G&quot;) %&gt;% select(no_focal, subject, x0_1m:x1_3m, groom, groom2, study_period) %&gt;% replace_na(list(groom = &quot;NA&quot;, groom2 = &quot;NA&quot;)) -&gt; focal_prox_fh 続いて、上記のうち各メス同士が毛づくろいをしていなかったポイント数を算出する(= 分母)。 prox_denom_fh &lt;- matrix(nrow = length(femaleID2), ncol = length(femaleID2)) for(i in seq_along(femaleID2)){ for(j in seq_along(femaleID2)){ prox_denom_fh[i,j] &lt;- focal_prox_fh %&gt;% filter(subject == femaleID2[i]) %&gt;% filter(groom != femaleID2[j] &amp; groom2 != femaleID2[j]) %&gt;% nrow() } } ## 転置行列と足す prox_denom_fh2 &lt;- prox_denom_fh + t(prox_denom_fh) ## 対角成分は0にする diag(prox_denom_fh2) &lt;- 0 rownames(prox_denom_fh2) &lt;- femaleID2 colnames(prox_denom_fh2) &lt;- femaleID2 続いて、各メスが毛づくろいをしていなかったポイントのうち近接していたポイント数を算出する。 prox_numer_fh &lt;- matrix(nrow = length(femaleID2), ncol = length(femaleID2)) for(i in seq_along(femaleID2)){ for(j in seq_along(femaleID2)){ prox_numer_fh[i,j] &lt;- focal_prox_fh %&gt;% filter(subject == femaleID2[i]) %&gt;% filter(groom != femaleID2[j] &amp; groom2 != femaleID2[j]) %&gt;% filter(str_detect(x0_1m, femaleID2[j])|str_detect(x1_3m, femaleID2[j])) %&gt;% nrow() } } ## 転置行列と足す prox_numer_fh2 &lt;- prox_numer_fh + t(prox_numer_fh) ## 対角成分は0にする rownames(prox_numer_fh2) &lt;- femaleID2 colnames(prox_numer_fh2) &lt;- femaleID2 最後に、これらを基に近接時間割合を算出する。 prox_mat_fh &lt;- prox_numer_fh2/prox_denom_fh2 diag(prox_mat_fh) &lt;- 0 2.4.3 CSIの算出 最後に、CSIを算出する。ここでは、aninetパッケージのdyadic_csi()関数を用いる。 library(aninet) CSI_fh_female &lt;- dyadic_csi(list(groom_mat_fh, prox_mat_fh)) colnames(CSI_fh_female) &lt;- femaleID2 rownames(CSI_fh_female) &lt;- femaleID2 CSIを図示すると以下のようになる。 CSI_fh_female %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot;ID1&quot;) %&gt;% pivot_longer(2:16, names_to = &quot;ID2&quot;, values_to = &quot;CSI&quot;) %&gt;% ggplot(aes(x = ID1, y = ID2))+ geom_tile(aes(fill = CSI))+ scale_fill_gradient2(high = muted(&quot;blue&quot;), low = muted(&quot;red&quot;), mid = &quot;white&quot;, midpoint = 1)+ theme(aspect.ratio = 1)+ labs(x = &quot;&quot;, y = &quot;&quot;) 2.5 CSIの算出(Tam生存前まで) 算出するメスのIDは、この期間のデータがあった以下の通り。 femaleID2 &lt;- sort(c(&quot;Kil&quot;,&quot;Mik&quot;,&quot;Koh&quot;,&quot;Aka&quot;,&quot;Tam&quot;,&quot;Ten&quot;,&quot;Ntr&quot;,&quot;Hen&quot;,&quot;Hot&quot;,&quot;Tot&quot;,&quot;Mei&quot;,&quot;Ako&quot;,&quot;Kol&quot;,&quot;Mal&quot;,&quot;Kit&quot;,&quot;Kun&quot;)) 2.5.1 毛づくろい時間割合の算出 focal_withTam &lt;- bind_rows(focal_18m_b, focal_19m_b, focal_19nm, focal_20m, focal_21nm) %&gt;% mutate(date = as_date(date)) %&gt;% filter(date &lt;= &quot;2021-03-14&quot;) ## 毛づくろい相手を表す列を作成 focal_withTam %&gt;% mutate(groom = ifelse(groomer == subject,groomee,groomer), groom2 = ifelse(groomer2 == subject,groomee2,groomer2)) -&gt; focal_withTam_b 各メスの追跡時間(総瞬間サンプリングポイント数)を算出する。 focal_withTam_b %&gt;% filter(subject %in% femaleID2) %&gt;% group_by(subject) %&gt;% summarise(dur = n()) -&gt; focal_duration_withTam 対象となるメスと毛づくろいしていたポイントを抽出する。 focal_withTam_b %&gt;% filter(activity == &quot;G&quot;) %&gt;% filter(subject %in% femaleID2) %&gt;% select(date, no_focal, time, subject, groom, groom2) %&gt;% pivot_longer(cols = c(&quot;groom&quot;,&quot;groom2&quot;), names_to = &quot;groom&quot;, values_to = &quot;ID&quot;) %&gt;% filter(ID %in% femaleID2) -&gt; groom_pairs_withTam 最後に、毛づくろい時間割合を算出してマトリックスにする。 groom_mat_withTam &lt;- df.to.mat(groom_pairs_withTam, actor = &quot;subject&quot;, receiver = &quot;ID&quot;, sym = T, tob = focal_duration_withTam$dur) 2.5.2 近接時間割合の算出 続いて、近接時間割合を算出する。なお、互いに毛づくろいをしていた時間は除く点は注意が必要である。 まず、地上採食・休息・毛づくろいのポイントのみを抽出する。 focal_withTam_b %&gt;% filter(activity %in% c(&quot;F&quot;,&quot;R&quot;,&quot;G&quot;) &amp; T_G == &quot;G&quot;) %&gt;% select(no_focal, subject, x0_1m:x1_3m, groom, groom2, study_period) %&gt;% replace_na(list(groom = &quot;NA&quot;, groom2 = &quot;NA&quot;)) -&gt; focal_prox_withTam 続いて、上記のうち各メス同士が毛づくろいをしていなかったポイント数を算出する(= 分母)。 prox_denom_withTam &lt;- matrix(nrow = length(femaleID2), ncol = length(femaleID2)) for(i in seq_along(femaleID2)){ for(j in seq_along(femaleID2)){ prox_denom_withTam[i,j] &lt;- focal_prox_withTam %&gt;% filter(subject == femaleID2[i]) %&gt;% filter(groom != femaleID2[j] &amp; groom2 != femaleID2[j]) %&gt;% nrow() } } ## 転置行列と足す prox_denom_withTam2 &lt;- prox_denom_withTam + t(prox_denom_withTam) ## 対角成分は0にする diag(prox_denom_withTam2) &lt;- 0 rownames(prox_denom_withTam2) &lt;- femaleID2 colnames(prox_denom_withTam2) &lt;- femaleID2 続いて、各メスが毛づくろいをしていなかったポイントのうち近接していたポイント数を算出する。 prox_numer_withTam &lt;- matrix(nrow = length(femaleID2), ncol = length(femaleID2)) for(i in seq_along(femaleID2)){ for(j in seq_along(femaleID2)){ prox_numer_withTam[i,j] &lt;- focal_prox_withTam %&gt;% filter(subject == femaleID2[i]) %&gt;% filter(groom != femaleID2[j] &amp; groom2 != femaleID2[j]) %&gt;% filter(str_detect(x0_1m, femaleID2[j])|str_detect(x1_3m, femaleID2[j])) %&gt;% nrow() } } ## 転置行列と足す prox_numer_withTam2 &lt;- prox_numer_withTam + t(prox_numer_withTam) ## 対角成分は0にする rownames(prox_numer_withTam2) &lt;- femaleID2 colnames(prox_numer_withTam2) &lt;- femaleID2 最後に、これらを基に近接時間割合を算出する。 prox_mat_withTam &lt;- prox_numer_withTam2/prox_denom_withTam2 diag(prox_mat_withTam) &lt;- 0 2.5.3 CSIの算出 最後に、CSIを算出する。ここでは、aninetパッケージのdyadic_csi()関数を用いる。 library(aninet) CSI_withTam_female &lt;- dyadic_csi(list(groom_mat_withTam, prox_mat_withTam)) colnames(CSI_withTam_female) &lt;- femaleID2 rownames(CSI_withTam_female) &lt;- femaleID2 CSIを図示すると以下のようになる。 CSI_withTam_female %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot;ID1&quot;) %&gt;% pivot_longer(2:16, names_to = &quot;ID2&quot;, values_to = &quot;CSI&quot;) %&gt;% ggplot(aes(x = ID1, y = ID2))+ geom_tile(aes(fill = CSI))+ scale_fill_gradient2(high = muted(&quot;blue&quot;), low = muted(&quot;red&quot;), mid = &quot;white&quot;, midpoint = 1)+ theme(aspect.ratio = 1)+ labs(x = &quot;&quot;, y = &quot;&quot;) 2.6 CSIの算出(調査期間ごと) 2.6.1 毛づくろい時間割合の算出 各メスの追跡時間(総瞬間サンプリングポイント数)を算出する。 focal_all_b %&gt;% filter(subject %in% femaleID) %&gt;% group_by(subject, study_period) %&gt;% summarise(dur = n()) -&gt; focal_duration_sp 対象となるメスと毛づくろいしていたポイントを抽出する。 focal_all_b %&gt;% filter(activity == &quot;G&quot;) %&gt;% filter(subject %in% femaleID) %&gt;% select(date, no_focal, time, subject, groom, groom2, study_period) %&gt;% pivot_longer(cols = c(&quot;groom&quot;,&quot;groom2&quot;), names_to = &quot;groom&quot;, values_to = &quot;ID&quot;) %&gt;% filter(ID %in% femaleID) -&gt; groom_pairs 最後に、毛づくろい時間割合を算出してマトリックスにする。 groom_mat_sp &lt;- list() sp &lt;- unique(groom_pairs$study_period) for(i in c(1,2,3,5)){ groom_mat_sp[[i]] &lt;- df.to.mat(groom_pairs %&gt;% filter(study_period == sp[i]), actor = &quot;subject&quot;, receiver = &quot;ID&quot;, sym = T, tob = focal_duration_sp %&gt;% filter(study_period == sp[i]) %&gt;%.$dur) } ## 2021非交尾期はホタルがfemaleIDに含まれるメスと毛づくろいをしなかったので、別に求める。 groom_mat_sp[[4]] &lt;- df.to.mat(groom_pairs %&gt;% filter(study_period == sp[4]), actor = &quot;subject&quot;, receiver = &quot;ID&quot;, sym = T, tob = focal_duration_sp %&gt;% filter(study_period == sp[4]) %&gt;% filter(subject != &quot;Hot&quot;) %&gt;% .$dur) ## ホタルの行列を追加 groom_mat_sp[[4]] %&gt;% data.frame() %&gt;% bind_rows(data.frame(row.names = &quot;Hot&quot;)) %&gt;% mutate(Hot = 0L)-&gt; groom_mat_sp4 ## 行名と列名を並べ替え groom_mat_sp4[15,1:15] &lt;- 0 groom_mat_sp[[4]] &lt;- groom_mat_sp4 %&gt;% as.matrix() groom_mat_sp[[4]] &lt;- groom_mat_sp[[4]][sort(rownames(groom_mat_sp[[4]])),sort(colnames(groom_mat_sp[[4]]))] 2.6.2 近接時間割合の算出 続いて、近接時間割合を算出する。なお、互いに毛づくろいをしていた時間は除く点は注意が必要である。 続いて、上記のうち各メス同士が毛づくろいをしていなかったポイント数を算出する(= 分母)。 mat &lt;- matrix(nrow = length(femaleID), ncol = length(femaleID)) prox_denom_sp &lt;- list(mat,mat,mat,mat,mat) prox_denom_sp2 &lt;- list(mat,mat,mat,mat,mat) for(i in seq_along(sp)){ for(j in seq_along(femaleID)){ for(k in seq_along(femaleID)) prox_denom_sp[[i]][j,k] &lt;- focal_prox %&gt;% filter(study_period == sp[i]) %&gt;% filter(subject == femaleID[j]) %&gt;% filter(groom != femaleID[k] &amp; groom2 != femaleID[k]) %&gt;% nrow() diag(prox_denom_sp[[i]]) &lt;- 0 rownames(prox_denom_sp[[i]]) &lt;- femaleID colnames(prox_denom_sp[[i]]) &lt;- femaleID prox_denom_sp2[[i]] &lt;- prox_denom_sp[[i]] + t(prox_denom_sp[[i]]) } } 続いて、各メスが毛づくろいをしていなかったポイントのうち近接していたポイント数を算出する。 prox_numer_sp &lt;- list(mat,mat,mat,mat,mat) prox_numer_sp2 &lt;- list(mat,mat,mat,mat,mat) for(i in seq_along(sp)){ for(j in seq_along(femaleID)){ for(k in seq_along(femaleID)) prox_numer_sp[[i]][j,k] &lt;- focal_prox %&gt;% filter(study_period == sp[i]) %&gt;% filter(subject == femaleID[j]) %&gt;% filter(groom != femaleID[k] &amp; groom2 != femaleID[k]) %&gt;% filter(str_detect(x0_1m, femaleID[k])|str_detect(x1_3m, femaleID[k])) %&gt;% nrow() diag(prox_numer_sp[[i]]) &lt;- 0 rownames(prox_numer_sp[[i]]) &lt;- femaleID colnames(prox_numer_sp[[i]]) &lt;- femaleID prox_numer_sp2[[i]] &lt;- prox_numer_sp[[i]] + t(prox_numer_sp[[i]]) } } 最後に、これらを基に近接時間割合を算出する。 prox_mat_sp &lt;- list(mat,mat,mat,mat,mat) for(i in seq_along(sp)){ prox_mat_sp[[i]] &lt;- prox_numer_sp2[[i]]/prox_denom_sp2[[i]] diag(prox_mat_sp[[i]]) &lt;- 0 } 2.6.3 CSIの算出 最後に、CSIを算出する。ここでは、aninetパッケージのdyadic_csi()関数を用いる。 library(aninet) CSI_sp_female &lt;- list(mat,mat,mat,mat,mat) for(i in seq_along(sp)){ CSI_sp_female[[i]] &lt;- dyadic_csi(list(groom_mat_sp[[i]], prox_mat_sp[[i]])) colnames(CSI_sp_female[[i]]) &lt;- femaleID rownames(CSI_sp_female[[i]]) &lt;- femaleID } CSIを図示すると以下のようになる。 CSI_sp_df &lt;- data.frame() for(i in seq_along(sp)){ CSI_df &lt;- CSI_sp_female[[i]] %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot;ID1&quot;) %&gt;% pivot_longer(2:16, names_to = &quot;ID2&quot;, values_to = &quot;CSI&quot;) %&gt;% mutate(study_period = sp[i]) CSI_sp_df &lt;- bind_rows(CSI_sp_df, CSI_df) } CSI_sp_df %&gt;% ggplot(aes(x = ID1, y = ID2))+ geom_tile(aes(fill = CSI))+ scale_fill_gradient2(high = muted(&quot;blue&quot;), low = muted(&quot;red&quot;), mid = &quot;white&quot;, midpoint = 1)+ theme(aspect.ratio = 1, axis.text.x = element_text(angle = -45, size = 7), axis.text.y = element_text(angle = -45, size = 7))+ labs(x = &quot;&quot;, y = &quot;&quot;)+ facet_rep_wrap(~study_period, repeat.tick.labels = TRUE) 各調査期間のCSIマトリックス間の相関は以下の通り。 # r &lt;- matrix(ncol = 5, nrow = 5) # # for(i in seq_along(sp)){ # for(j in seq_along(sp)){ # result &lt;- mantel(CSI_sp_female[[i]], CSI_sp_female[[j]]) # r[i,j] &lt;- result$statistic # } # } # # rownames(r) &lt;- sp # colnames(r) &lt;- sp # # r "],["04_CSI_TY.html", "3 TY・ITとメスのCSIの計算 3.1 CSIの定義 3.2 TYとメスのCSIの算出 3.3 ITとメスのCSIの算出 3.4 分母をTYとIT両方の頻度の平均値にする場合 3.5 算出に使用したメスの個体追跡データの概要", " 3 TY・ITとメスのCSIの計算 3.1 CSIの定義 ここでは、TY・ITとのCSIを算出する。 算出方法は Yamaguchi &amp; Kazahari (2022) に従う。CSIの算出式は以下の通り。なお、\\(i = 1,2,3,...,N\\)はメスのIDを表す。\\(P_i\\)の算出の際にはTY/ITと毛づくろいしているポイントは除いた。対象としたのは2018年時点で5歳以上だった非発情の個体である。 \\(G_{i}\\): メスiとTY/ITの毛づくろい時間割合 (TYと毛づくろいしたポイント数/総ポイント数) \\(P_{i}\\): メスiとTY/ITの近接時間割合 (3m以内にTYがいたポイント数/地上採食または休息したポイント数) \\(\\overline{G}: \\frac{1}{N} \\sum^{N}_{i=1}G_{i}\\) \\(\\overline{P}: \\frac{1}{N} \\sum^{N}_{i=1}P_{i}\\) \\[ CSI_{i} = \\frac{\\left(\\frac{G_{i}}{\\overline{G}} +\\frac{P_{i}}{\\overline{P}}\\right)}{2} \\;\\;(i = 1,2,\\dots,N) \\] 使用するのは2018年交尾期、2019年交尾期、2019年非交尾期、2021年非交尾期、2022年非交尾期のデータである。 3.2 TYとメスのCSIの算出 3.2.1 データの読み込みと加工 まずは、TYの出入りがあった2019年交尾期、2021年非交尾期についてTYが確認できた時間帯のデータを読み込む。 TY_19m &lt;- read_excel(&quot;../Data/data/2019mating/2019mating_raw.xlsx&quot;, sheet = &quot;male_presence_long&quot;) %&gt;% filter(maleID == &quot;TY&quot;) %&gt;% mutate_at(5:6, ~make_datetime(year(date), month(date), mday(date), hour(.),minute(.))) %&gt;% mutate(date = as_date(date)) %&gt;% ## 分派集団にいるときは除く filter(groupID != 41 &amp; groupID != 53 &amp; groupID != 54) TY_21nm &lt;- read_excel(&quot;../Data/data/2021nonmating/2021nonmating_raw.xlsx&quot;, sheet = &quot;male_presence_long&quot;) %&gt;% filter(maleID == &quot;TY&quot;) %&gt;% mutate_at(5:6, ~make_datetime(year(date), month(date), mday(date), hour(.),minute(.))) %&gt;% mutate(date = as_date(date)) 上記2つの期間の個体追跡データに、各個体追跡セッション中にTYが確認できていたかを表す列を追加し、TYが確認できたものだけを抽出する(focal_19m_b、focal_21nm_b)。 focal_19m %&gt;% distinct(no_focal, date, start_time, fin_time) %&gt;% left_join(TY_19m %&gt;% select(date, male_presence, first, last), by = &quot;date&quot;) %&gt;% ## 個体追跡セッション中にTYが確認されていたか mutate(TY = ifelse((first &lt;= start_time &amp; last &gt;= fin_time)| (first &gt;= start_time &amp; first &lt;= fin_time)| (last &gt;= start_time &amp; last &lt;= fin_time), 1, 0)) %&gt;% replace_na(list(TY = 0)) -&gt; focal_19m_TY focal_19m %&gt;% left_join(focal_19m_TY %&gt;% select(no_focal, TY), by = &quot;no_focal&quot;) %&gt;% filter(TY == &quot;1&quot;) -&gt; focal_19m_TY_b focal_21nm %&gt;% distinct(no_focal, date, start_time, fin_time) %&gt;% left_join(TY_21nm %&gt;% select(date, male_presence, first, last), by = &quot;date&quot;) %&gt;% ## 個体追跡セッション中にTYが確認されていたか mutate(TY = ifelse((first &lt;= start_time &amp; last &gt;= fin_time)| (first &gt;= start_time &amp; first &lt;= fin_time)| (last &gt;= start_time &amp; last &lt;= fin_time), 1, 0)) %&gt;% replace_na(list(TY = 0)) -&gt; focal_21nm_TY focal_21nm %&gt;% left_join(focal_21nm_TY %&gt;% select(no_focal, TY), by = &quot;no_focal&quot;) %&gt;% filter(TY == &quot;1&quot;) -&gt; focal_21nm_TY_b 交尾期のデータについて、追跡個体が発情しているかの列を追加し、発情していない日のデータのみを抽出する(focal_18m_TY_b、focal_19m_TY_b)。 focal_18m %&gt;% left_join(female_18m %&gt;% rename(subject = femaleID) %&gt;% select(date, subject, rs2) , by = c(&quot;date&quot;, &quot;subject&quot;)) %&gt;% filter(rs2 == &quot;0&quot;) -&gt; focal_18m_TY_b focal_19m_TY_b %&gt;% left_join(female_19m %&gt;% rename(subject = femaleID) %&gt;% select(date, subject, rs2) , by = c(&quot;date&quot;, &quot;subject&quot;)) %&gt;% filter(rs2 == &quot;0&quot;) -&gt; focal_19m_TY_b 3.2.2 CSIの算出(全調査期間) 3.2.2.1 毛づくろい時間割合の算出 算出のためにデータを加工する。 ## 全期間を結合 focal_all_TY &lt;- bind_rows(focal_18m_TY_b, focal_19m_TY_b, focal_19nm, focal_21nm_TY_b, focal_22nm) ## 毛づくろい相手を表す列を追加 focal_all_TY %&gt;% mutate(groom = ifelse(groomer == subject,groomee,groomer), groom2 = ifelse(groomer2 == subject,groomee2,groomer2)) -&gt; focal_all_TY_b 各メスの追跡時間(総瞬間サンプリングポイント数)を算出する。 focal_all_TY_b %&gt;% group_by(subject) %&gt;% summarise(dur = n()) %&gt;% ungroup() -&gt; focal_duration_TY 各個体のTYとの毛づくろい時間を算出する。 focal_all_TY_b %&gt;% filter(groom == &quot;TY&quot;|groom2 == &quot;TY&quot;) %&gt;% group_by(subject) %&gt;% summarise(no_groom = n()) %&gt;% ungroup()-&gt; no_groom_TY 最後に、毛づくろい時間割合を算出する。 left_join(focal_duration_TY, no_groom_TY, by = &quot;subject&quot;) %&gt;% replace_na(list(no_groom = 0)) %&gt;% mutate(prop_groom = no_groom/dur) -&gt; prop_groom_TY 3.2.2.2 近接時間割合 地上採食/地上休息・毛づくろい時にTYが3m以内にいた時間割合を算出する。 まずは、地上採食/地上休息・毛づくろいのデータのみを抽出する。また、TYと毛づくろいしているポイントは除外する。 focal_all_TY_b %&gt;% filter(activity %in% c(&quot;F&quot;,&quot;R&quot;,&quot;G&quot;) &amp; T_G == &quot;G&quot;) %&gt;% select(no_focal, subject, x0_1m:x1_3m, groom, groom2, study_period) %&gt;% replace_na(list(groom = &quot;NA&quot;, groom2 = &quot;NA&quot;)) %&gt;% filter(!(groom == &quot;TY&quot;|groom2 == &quot;TY&quot;)) -&gt; focal_prox_TY 分母を算出する。なお、TYと毛づくろいしていたポイントは分母に含まないものとする。 focal_prox_TY %&gt;% group_by(subject) %&gt;% summarise(dur = n()) %&gt;% ungroup() -&gt; prox_duration_TY TYと3m以内に近接していたポイント数を算出する。 focal_prox_TY %&gt;% filter(str_detect(x0_1m, &quot;TY&quot;)|str_detect(x1_3m, &quot;TY&quot;)) %&gt;% group_by(subject) %&gt;% summarise(no_prox = n()) %&gt;% ungroup() -&gt; no_prox_TY 最後に、近接時間割合を算出する。 left_join(prox_duration_TY, no_prox_TY, by = &quot;subject&quot;) %&gt;% mutate(prop_prox = no_prox/dur) -&gt; prop_prox_TY 3.2.2.3 CSIの算出 それでは、上記のデータを用いてCSIを算出する。 ## 平均毛づくろい時間割合 mean_groom_TY &lt;- mean(prop_groom_TY$prop_groom) ## 平均近接時間割合 mean_prox_TY &lt;- mean(prop_prox_TY$prop_prox) ## CSIの算出 ### 平均値 prop_groom_TY %&gt;% left_join(prop_prox_TY, by = &quot;subject&quot;) %&gt;% mutate(CSI_TY = ((prop_groom/mean_groom_TY) + (prop_prox/mean_prox_TY))/2) -&gt; CSI_TY 算出した値が以下の通り。Kitは一日TYに長時間毛づくろいした日があり、それが強く影響したようだ。 CSI_TY %&gt;% mutate(subject = fct_reorder(subject, CSI_TY)) %&gt;% ggplot(aes(x = subject, y = CSI_TY))+ geom_col(color = &quot;black&quot;, fill = &quot;white&quot;, size =0.3)+ theme_classic(base_size=12, base_family = &quot;Arial&quot;)+ xlab(&quot;&quot;)+ ylab(expression(paste(CSI, &quot; with &quot;, italic(TY))))+ labs(title = &quot;A&quot;)+ coord_flip(ylim = c(0,5.3)) + scale_y_continuous(breaks = seq(0,5.2, by= 0.5), expand= c(0,0))+ theme_bw()+ theme(aspect.ratio=1, axis.text.y = element_text(face = &quot;bold.italic&quot;, hjust=0, family = &quot;Times New Roman&quot;), axis.text.x = element_text(family = &quot;Times New Roman&quot;, face = &quot;bold&quot;), axis.ticks.y = element_blank(), axis.title.y = element_text(size = 8, family = &quot;Times New Roman&quot;), axis.title.x = element_text(size = 10.5, family = &quot;Times New Roman&quot;), plot.margin=grid::unit(c(0,0,0,0), &quot;mm&quot;), plot.title = element_text(family = &quot;Times New Roman&quot;, hjust = 0)) -&gt; p_CSI_TY p_CSI_TY # ggsave(&quot;figures/p_CSI_TY.tiff&quot;, # p_CSI_TY, width = 100, height = 100, dpi = 1500, # units = &quot;mm&quot;) 3.2.3 CSIの算出(2018交尾期～2019交尾期) 3.2.3.1 毛づくろい時間割合の算出 算出のためにデータを加工する。 ## 期間を結合 focal_fh_TY &lt;- bind_rows(focal_18m_TY_b, focal_19m_TY_b, focal_19nm) ## 毛づくろい相手を表す列を追加 focal_fh_TY %&gt;% mutate(groom = ifelse(groomer == subject,groomee,groomer), groom2 = ifelse(groomer2 == subject,groomee2,groomer2)) -&gt; focal_fh_TY_b 各メスの追跡時間(総瞬間サンプリングポイント数)を算出する。 focal_fh_TY_b %&gt;% group_by(subject) %&gt;% summarise(dur = n()) %&gt;% ungroup() -&gt; focal_duration_fh_TY 各個体のTYとの毛づくろい時間を算出する。 focal_fh_TY_b %&gt;% filter(groom == &quot;TY&quot;|groom2 == &quot;TY&quot;) %&gt;% group_by(subject) %&gt;% summarise(no_groom = n()) %&gt;% ungroup() -&gt; no_groom_fh_TY 最後に、毛づくろい時間割合を算出する。 left_join(focal_duration_fh_TY, no_groom_fh_TY, by = &quot;subject&quot;) %&gt;% replace_na(list(no_groom = 0)) %&gt;% mutate(prop_groom = no_groom/dur) -&gt; prop_groom_fh_TY 3.2.3.2 近接時間割合 地上採食/地上休息・毛づくろい時にTYが3m以内にいた時間割合を算出する。 まずは、地上採食/地上休息・毛づくろいのデータのみを抽出する。また、TYと毛づくろいしているポイントは除外する。 focal_fh_TY_b %&gt;% filter(activity %in% c(&quot;F&quot;,&quot;R&quot;,&quot;G&quot;) &amp; T_G == &quot;G&quot;) %&gt;% select(no_focal, subject, x0_1m:x1_3m, groom, groom2) %&gt;% replace_na(list(groom = &quot;NA&quot;, groom2 = &quot;NA&quot;)) %&gt;% filter(!(groom == &quot;TY&quot;|groom2 == &quot;TY&quot;)) -&gt; focal_prox_fh_TY 分母を算出する。なお、TYと毛づくろいしていたポイントは分母に含まないものとする。 focal_prox_fh_TY %&gt;% group_by(subject) %&gt;% summarise(dur = n()) %&gt;% ungroup() -&gt; prox_duration_fh_TY TYと3m以内に近接していたポイント数を算出する。 focal_prox_fh_TY %&gt;% filter(str_detect(x0_1m, &quot;TY&quot;)|str_detect(x1_3m, &quot;TY&quot;)) %&gt;% group_by(subject) %&gt;% summarise(no_prox = n()) %&gt;% ungroup() -&gt; no_prox_fh_TY 最後に、近接時間割合を算出する。 left_join(prox_duration_fh_TY, no_prox_fh_TY, by = &quot;subject&quot;) %&gt;% mutate(prop_prox = no_prox/dur) -&gt; prop_prox_fh_TY 3.2.3.3 CSIの算出 それでは、上記のデータを用いてCSIを算出する。 ## 平均毛づくろい時間割合 mean_groom_fh_TY &lt;- mean(prop_groom_fh_TY$prop_groom) ## 平均近接時間割合 mean_prox_fh_TY &lt;- mean(prop_prox_fh_TY$prop_prox) ## CSIの算出 prop_groom_fh_TY %&gt;% left_join(prop_prox_fh_TY, by = &quot;subject&quot;) %&gt;% mutate(CSI_TY = ((prop_groom/mean_groom_fh_TY) + (prop_prox/mean_prox_fh_TY))/2) -&gt; CSI_fh_TY 算出した値が以下の通り。 CSI_fh_TY %&gt;% mutate(subject = fct_reorder(subject, CSI_TY)) %&gt;% ggplot(aes(x = subject, y = CSI_TY))+ geom_col(color = &quot;black&quot;, fill = &quot;white&quot;, size =0.3)+ theme_classic(base_size=12, base_family = &quot;Arial&quot;)+ xlab(&quot;&quot;)+ ylab(expression(CSI[i]))+ coord_flip(ylim = c(0,5.3)) + scale_y_continuous(breaks = seq(0,5.2, by= 0.5), expand= c(0,0))+ theme(aspect.ratio=1, axis.text.y = element_text(face = &quot;italic&quot;, hjust=0), axis.ticks.y = element_blank(), axis.title.y = element_text(size = 8), axis.title.x = element_text(size = 10.5), plot.margin=grid::unit(c(0,0,0,0), &quot;mm&quot;), plot.title = element_text(hjust = 0.5)) 3.2.4 CSIの算出(非交尾期のみ) 3.2.4.1 毛づくろい時間割合の算出 算出のためにデータを加工する。 ## 全期間を結合 focal_nm_TY &lt;- bind_rows(focal_19nm, focal_21nm_TY_b, focal_22nm) ## 毛づくろい相手を表す列を追加 focal_nm_TY %&gt;% mutate(groom = ifelse(groomer == subject,groomee,groomer), groom2 = ifelse(groomer2 == subject,groomee2,groomer2)) -&gt; focal_nm_TY_b 各メスの追跡時間(総瞬間サンプリングポイント数)を算出する。 focal_nm_TY_b %&gt;% group_by(subject) %&gt;% summarise(dur = n()) %&gt;% ungroup() -&gt; focal_duration_nm_TY 各個体のTYとの毛づくろい時間を算出する。 focal_nm_TY_b %&gt;% filter(groom == &quot;TY&quot;|groom2 == &quot;TY&quot;) %&gt;% group_by(subject) %&gt;% summarise(no_groom = n()) %&gt;% ungroup() -&gt; no_groom_nm_TY 最後に、毛づくろい時間割合を算出する。 left_join(focal_duration_nm_TY, no_groom_nm_TY, by = &quot;subject&quot;) %&gt;% replace_na(list(no_groom = 0)) %&gt;% mutate(prop_groom = no_groom/dur) -&gt; prop_groom_nm_TY 3.2.4.2 近接時間割合 地上採食/地上休息・毛づくろい時にTYが3m以内にいた時間割合を算出する。 まずは、地上採食/地上休息・毛づくろいのデータのみを抽出する。また、TYと毛づくろいしているポイントは除外する。 focal_nm_TY_b %&gt;% filter(activity %in% c(&quot;F&quot;,&quot;R&quot;,&quot;G&quot;) &amp; T_G == &quot;G&quot;) %&gt;% select(no_focal, subject, x0_1m:x1_3m, groom, groom2) %&gt;% replace_na(list(groom = &quot;NA&quot;, groom2 = &quot;NA&quot;)) %&gt;% filter(!(groom == &quot;TY&quot;|groom2 == &quot;TY&quot;)) -&gt; focal_prox_nm_TY 分母を算出する。なお、TYと毛づくろいしていたポイントは分母に含まないものとする。 focal_prox_nm_TY %&gt;% group_by(subject) %&gt;% summarise(dur = n()) %&gt;% ungroup() -&gt; prox_duration_nm_TY TYと3m以内に近接していたポイント数を算出する。 focal_prox_nm_TY %&gt;% filter(str_detect(x0_1m, &quot;TY&quot;)|str_detect(x1_3m, &quot;TY&quot;)) %&gt;% group_by(subject) %&gt;% summarise(no_prox = n()) %&gt;% ungroup() -&gt; no_prox_nm_TY 最後に、近接時間割合を算出する。 left_join(prox_duration_nm_TY, no_prox_nm_TY, by = &quot;subject&quot;) %&gt;% mutate(prop_prox = no_prox/dur) -&gt; prop_prox_nm_TY 3.2.4.3 CSIの算出 それでは、上記のデータを用いてCSIを算出する。 ## 平均毛づくろい時間割合 mean_groom_nm_TY &lt;- mean(prop_groom_nm_TY$prop_groom) ## 平均近接時間割合 mean_prox_nm_TY &lt;- mean(prop_prox_nm_TY$prop_prox) ## CSIの算出 prop_groom_nm_TY %&gt;% left_join(prop_prox_nm_TY, by = &quot;subject&quot;) %&gt;% mutate(CSI_TY = ((prop_groom/mean_groom_nm_TY) + (prop_prox/mean_prox_nm_TY))/2) -&gt; CSI_nm_TY 算出した値が以下の通り。 CSI_nm_TY %&gt;% mutate(subject = fct_reorder(subject, CSI_TY)) %&gt;% ggplot(aes(x = subject, y = CSI_TY))+ geom_col(color = &quot;black&quot;, fill = &quot;white&quot;, size =0.3)+ theme_classic(base_size=12, base_family = &quot;Arial&quot;)+ xlab(&quot;&quot;)+ ylab(expression(CSI[i]))+ coord_flip(ylim = c(0,5.3)) + scale_y_continuous(breaks = seq(0,5.2, by= 0.5), expand= c(0,0))+ theme(aspect.ratio=1, axis.text.y = element_text(face = &quot;italic&quot;, hjust=0), axis.ticks.y = element_blank(), axis.title.y = element_text(size = 8), axis.title.x = element_text(size = 10.5), plot.margin=grid::unit(c(0,0,0,0), &quot;mm&quot;), plot.title = element_text(hjust = 0.5)) 3.2.5 CSIの算出(調査期間ごと) 3.2.5.1 毛づくろい時間割合の算出 各メスの追跡時間(総瞬間サンプリングポイント数)を調査期間ごとに算出する。 focal_all_TY_b %&gt;% group_by(subject, study_period) %&gt;% summarise(dur = n()) %&gt;% ungroup() -&gt; focal_duration_sp_TY 各個体のTYとの毛づくろい時間を算出する。 focal_all_TY_b %&gt;% filter(groom == &quot;TY&quot;|groom2 == &quot;TY&quot;) %&gt;% group_by(subject, study_period) %&gt;% summarise(no_groom = n()) %&gt;% ungroup() -&gt; no_groom_sp_TY 最後に、毛づくろい時間割合を算出する。 left_join(focal_duration_sp_TY, no_groom_sp_TY, by = c(&quot;subject&quot;,&quot;study_period&quot;)) %&gt;% replace_na(list(no_groom = 0)) %&gt;% mutate(prop_groom = no_groom/dur) -&gt; prop_groom_sp_TY 3.2.5.2 近接時間割合 地上採食/地上休息・毛づくろい時にTYが3m以内にいた時間割合を算出する。 調査期間ごとに分母を算出する。なお、TYと毛づくろいしていたポイントは分母に含まないものとする。 focal_prox_TY %&gt;% group_by(subject, study_period) %&gt;% summarise(dur = n()) %&gt;% ungroup() -&gt; prox_duration_sp_TY TYと3m以内に近接していたポイント数を算出する。 focal_prox_TY %&gt;% filter(str_detect(x0_1m, &quot;TY&quot;)|str_detect(x1_3m, &quot;TY&quot;)) %&gt;% group_by(subject, study_period) %&gt;% summarise(no_prox = n()) %&gt;% ungroup() -&gt; no_prox_sp_TY 最後に、近接時間割合を算出する。 left_join(prox_duration_sp_TY, no_prox_sp_TY, by = c(&quot;subject&quot;,&quot;study_period&quot;)) %&gt;% replace_na(list(no_prox = 0)) %&gt;% mutate(prop_prox = no_prox/dur) -&gt; prop_prox_sp_TY 3.2.5.3 CSIの算出 それでは、上記のデータを用いてCSIを算出する。 ## CSIの算出 prop_groom_sp_TY %&gt;% left_join(prop_prox_sp_TY, by = c(&quot;subject&quot;,&quot;study_period&quot;)) %&gt;% group_by(study_period) %&gt;% mutate(mean_groom = mean(prop_groom), mean_prox = mean(prop_prox)) %&gt;% ungroup() %&gt;% mutate(CSI_TY = ((prop_groom/mean_groom) + (prop_prox/mean_prox))/2) -&gt; CSI_sp_TY 算出した値が以下の通り。 CSI_sp_TY %&gt;% ggplot(aes(x = study_period, y = CSI_TY))+ geom_point()+ geom_line(aes(group = subject))+ theme_bw()+ facet_rep_wrap(~subject, repeat.tick.labels = TRUE)+ ylab(expression(CSI[i])) 3.3 ITとメスのCSIの算出 3.3.1 データの読み込みと加工 まずは、ITの出入りがあった2019年交尾期、2021年非交尾期についてTYが確認できた時間帯のデータを読み込む。 IT_19m &lt;- read_excel(&quot;../Data/data/2019mating/2019mating_raw.xlsx&quot;, sheet = &quot;male_presence_long&quot;) %&gt;% filter(maleID == &quot;IT&quot;) %&gt;% mutate_at(5:6, ~make_datetime(year(date), month(date), mday(date), hour(.),minute(.))) %&gt;% mutate(date = as_date(date)) %&gt;% ## 分派集団にいるときは除く filter(groupID != 41 &amp; groupID != 53 &amp; groupID != 54) IT_21nm &lt;- read_excel(&quot;../Data/data/2021nonmating/2021nonmating_raw.xlsx&quot;, sheet = &quot;male_presence_long&quot;) %&gt;% filter(maleID == &quot;IT&quot;) %&gt;% mutate_at(5:6, ~make_datetime(year(date), month(date), mday(date), hour(.),minute(.))) %&gt;% mutate(date = as_date(date)) 上記2つの期間の個体追跡データに、各個体追跡セッション中にITが確認できていたかを表す列を追加し、ITが確認できたものだけを抽出する(focal_19m_b、focal_21nm_b)。 focal_19m %&gt;% distinct(no_focal, date, start_time, fin_time) %&gt;% left_join(IT_19m %&gt;% select(date, male_presence, first, last), by = &quot;date&quot;) %&gt;% ## 個体追跡セッション中にITが確認されていたか mutate(IT = ifelse((first &lt;= start_time &amp; last &gt;= fin_time)| (first &gt;= start_time &amp; first &lt;= fin_time)| (last &gt;= start_time &amp; last &lt;= fin_time), 1, 0)) %&gt;% replace_na(list(IT = 0)) -&gt; focal_19m_IT focal_19m %&gt;% left_join(focal_19m_IT %&gt;% select(no_focal, IT), by = &quot;no_focal&quot;) %&gt;% filter(IT == &quot;1&quot;) -&gt; focal_19m_IT_b focal_21nm %&gt;% distinct(no_focal, date, start_time, fin_time) %&gt;% left_join(IT_21nm %&gt;% select(date, male_presence, first, last), by = &quot;date&quot;) %&gt;% ## 個体追跡セッション中にITが確認されていたか mutate(IT = ifelse((first &lt;= start_time &amp; last &gt;= fin_time)| (first &gt;= start_time &amp; first &lt;= fin_time)| (last &gt;= start_time &amp; last &lt;= fin_time), 1, 0)) %&gt;% replace_na(list(IT = 0)) -&gt; focal_21nm_IT focal_21nm %&gt;% left_join(focal_21nm_IT %&gt;% select(no_focal, IT), by = &quot;no_focal&quot;) %&gt;% filter(IT == &quot;1&quot;) -&gt; focal_21nm_IT_b 交尾期のデータについて、追跡個体が発情しているかの列を追加し、発情していない日のデータのみを抽出する(focal_18m_IT_b、focal_19m_IT_b)。 focal_18m %&gt;% left_join(female_18m %&gt;% rename(subject = femaleID) %&gt;% select(date, subject, rs2) , by = c(&quot;date&quot;, &quot;subject&quot;)) %&gt;% filter(rs2 == &quot;0&quot;) -&gt; focal_18m_IT_b focal_19m_IT_b %&gt;% left_join(female_19m %&gt;% rename(subject = femaleID) %&gt;% select(date, subject, rs2) , by = c(&quot;date&quot;, &quot;subject&quot;)) %&gt;% filter(rs2 == &quot;0&quot;) -&gt; focal_19m_IT_b 3.3.2 CSIの算出(全調査期間) 3.3.2.1 毛づくろい時間割合の算出 算出のためにデータを加工する。 ## 全期間を結合 focal_all_IT &lt;- bind_rows(focal_18m_IT_b, focal_19m_IT_b, focal_19nm, focal_21nm_IT_b) ## 毛づくろい相手を表す列を追加 focal_all_IT %&gt;% mutate(groom = ifelse(groomer == subject,groomee,groomer), groom2 = ifelse(groomer2 == subject,groomee2,groomer2)) -&gt; focal_all_IT_b 各メスの追跡時間(総瞬間サンプリングポイント数)を算出する。 focal_all_IT_b %&gt;% group_by(subject) %&gt;% summarise(dur = n()) %&gt;% ungroup() -&gt; focal_duration_IT 各個体のITとの毛づくろい時間を算出する。 focal_all_IT_b %&gt;% filter(groom == &quot;IT&quot;|groom2 == &quot;IT&quot;) %&gt;% group_by(subject) %&gt;% summarise(no_groom = n())%&gt;% ungroup() -&gt; no_groom_IT 最後に、毛づくろい時間割合を算出する。 left_join(focal_duration_IT, no_groom_IT, by = &quot;subject&quot;) %&gt;% replace_na(list(no_groom = 0)) %&gt;% mutate(prop_groom = no_groom/dur) -&gt; prop_groom_IT 3.3.2.2 近接時間割合 地上採食/地上休息・毛づくろい時にITが3m以内にいた時間割合を算出する。 まずは、地上採食/地上休息・毛づくろいのデータのみを抽出する。また、ITと毛づくろいしているポイントは除外する。 focal_all_IT_b %&gt;% filter(activity %in% c(&quot;F&quot;,&quot;R&quot;,&quot;G&quot;) &amp; T_G == &quot;G&quot;) %&gt;% select(no_focal, subject, x0_1m:x1_3m, groom, groom2, study_period) %&gt;% replace_na(list(groom = &quot;NA&quot;, groom2 = &quot;NA&quot;)) %&gt;% filter(!(groom == &quot;IT&quot;|groom2 == &quot;IT&quot;)) -&gt; focal_prox_IT 分母を算出する。なお、ITと毛づくろいしていたポイントは分母に含まないものとする。 focal_prox_IT %&gt;% group_by(subject) %&gt;% summarise(dur = n())%&gt;% ungroup() -&gt; prox_duration_IT ITと3m以内に近接していたポイント数を算出する。 focal_prox_IT %&gt;% filter(str_detect(x0_1m, &quot;IT&quot;)|str_detect(x1_3m, &quot;IT&quot;)) %&gt;% group_by(subject) %&gt;% summarise(no_prox = n())%&gt;% ungroup() -&gt; no_prox_IT 最後に、近接時間割合を算出する。 left_join(prox_duration_IT, no_prox_IT, by = &quot;subject&quot;) %&gt;% mutate(prop_prox = no_prox/dur) -&gt; prop_prox_IT 3.3.2.3 CSIの算出 それでは、上記のデータを用いてCSIを算出する。 ## 平均毛づくろい時間割合 mean_groom_IT &lt;- mean(prop_groom_IT$prop_groom) ## 平均近接時間割合 mean_prox_IT &lt;- mean(prop_prox_IT$prop_prox) ## CSIの算出 prop_groom_IT %&gt;% left_join(prop_prox_IT, by = &quot;subject&quot;) %&gt;% mutate(CSI_IT = ((prop_groom/mean_groom_IT) + (prop_prox/mean_prox_IT))/2) -&gt; CSI_IT 算出した値が以下の通り。Kitは一日ITに長時間毛づくろいした日があり、それが強く影響したようだ。 CSI_IT %&gt;% mutate(subject = fct_reorder(subject, CSI_IT)) %&gt;% ggplot(aes(x = subject, y = CSI_IT))+ geom_col(color = &quot;black&quot;, fill = &quot;white&quot;, size =0.3)+ theme_classic(base_size=12, base_family = &quot;Times New Roman&quot;)+ xlab(&quot;&quot;)+ ylab(expression(paste(CSI, &quot; with &quot;, italic(IT))))+ labs(title = &quot;B&quot;)+ coord_flip(ylim = c(0,6.0)) + scale_y_continuous(breaks = seq(0,7, by= 0.5), expand= c(0,0))+ theme_bw()+ theme(aspect.ratio=1, axis.text.y = element_text(face = &quot;bold.italic&quot;, hjust=0, family = &quot;Times New Roman&quot;), axis.text.x = element_text(family = &quot;Times New Roman&quot;, face = &quot;bold&quot;), axis.ticks.y = element_blank(), axis.title.y = element_text(size = 8, family = &quot;Times New Roman&quot;), axis.title.x = element_text(size = 10.5, family = &quot;Times New Roman&quot;), plot.margin=grid::unit(c(0,0,0,0), &quot;mm&quot;), plot.title = element_text(family = &quot;Times New Roman&quot;, hjust = 0)) -&gt; p_CSI_IT p_CSI_IT # ggsave(&quot;figures/p_CSI_IT.tiff&quot;, # p_CSI_IT, width = 100, height = 100, dpi = 1500, # units = &quot;mm&quot;) 3.3.3 CSIの算出(2018交尾期～2019交尾期) 3.3.3.1 毛づくろい時間割合の算出 算出のためにデータを加工する。 ## 期間を結合 focal_fh_IT &lt;- bind_rows(focal_18m_IT_b, focal_19m_IT_b, focal_19nm) ## 毛づくろい相手を表す列を追加 focal_fh_IT %&gt;% mutate(groom = ifelse(groomer == subject,groomee,groomer), groom2 = ifelse(groomer2 == subject,groomee2,groomer2)) -&gt; focal_fh_IT_b 各メスの追跡時間(総瞬間サンプリングポイント数)を算出する。 focal_fh_IT_b %&gt;% group_by(subject) %&gt;% summarise(dur = n())%&gt;% ungroup() -&gt; focal_duration_fh_IT 各個体のITとの毛づくろい時間を算出する。 focal_fh_IT_b %&gt;% filter(groom == &quot;IT&quot;|groom2 == &quot;IT&quot;) %&gt;% group_by(subject) %&gt;% summarise(no_groom = n())%&gt;% ungroup() -&gt; no_groom_fh_IT 最後に、毛づくろい時間割合を算出する。 left_join(focal_duration_fh_IT, no_groom_fh_IT, by = &quot;subject&quot;) %&gt;% replace_na(list(no_groom = 0)) %&gt;% mutate(prop_groom = no_groom/dur) -&gt; prop_groom_fh_IT 3.3.3.2 近接時間割合 地上採食/地上休息・毛づくろい時にITが3m以内にいた時間割合を算出する。 まずは、地上採食/地上休息・毛づくろいのデータのみを抽出する。また、ITと毛づくろいしているポイントは除外する。 focal_fh_IT_b %&gt;% filter(activity %in% c(&quot;F&quot;,&quot;R&quot;,&quot;G&quot;) &amp; T_G == &quot;G&quot;) %&gt;% select(no_focal, subject, x0_1m:x1_3m, groom, groom2) %&gt;% replace_na(list(groom = &quot;NA&quot;, groom2 = &quot;NA&quot;)) %&gt;% filter(!(groom == &quot;IT&quot;|groom2 == &quot;IT&quot;)) -&gt; focal_prox_fh_IT 分母を算出する。なお、ITと毛づくろいしていたポイントは分母に含まないものとする。 focal_prox_fh_IT %&gt;% group_by(subject) %&gt;% summarise(dur = n())%&gt;% ungroup() -&gt; prox_duration_fh_IT ITと3m以内に近接していたポイント数を算出する。 focal_prox_fh_IT %&gt;% filter(str_detect(x0_1m, &quot;IT&quot;)|str_detect(x1_3m, &quot;IT&quot;)) %&gt;% group_by(subject) %&gt;% summarise(no_prox = n())%&gt;% ungroup() -&gt; no_prox_fh_IT 最後に、近接時間割合を算出する。 left_join(prox_duration_fh_IT, no_prox_fh_IT, by = &quot;subject&quot;) %&gt;% replace_na(list(no_prox = 0)) %&gt;% mutate(prop_prox = no_prox/dur) -&gt; prop_prox_fh_IT 3.3.3.3 CSIの算出 それでは、上記のデータを用いてCSIを算出する。 ## 平均毛づくろい時間割合 mean_groom_fh_IT &lt;- mean(prop_groom_fh_IT$prop_groom) ## 平均近接時間割合 mean_prox_fh_IT &lt;- mean(prop_prox_fh_IT$prop_prox) ## CSIの算出 prop_groom_fh_IT %&gt;% left_join(prop_prox_fh_IT, by = &quot;subject&quot;) %&gt;% mutate(CSI_IT = ((prop_groom/mean_groom_fh_IT) + (prop_prox/mean_prox_fh_IT))/2) -&gt; CSI_fh_IT 算出した値が以下の通り。 CSI_fh_IT %&gt;% mutate(subject = fct_reorder(subject, CSI_IT)) %&gt;% ggplot(aes(x = subject, y = CSI_IT))+ geom_col(color = &quot;black&quot;, fill = &quot;white&quot;, size =0.3)+ theme_classic(base_size=12, base_family = &quot;Arial&quot;)+ xlab(&quot;&quot;)+ ylab(expression(CSI[i]))+ coord_flip(ylim = c(0,10)) + scale_y_continuous(breaks = seq(0,10, by= 1), expand= c(0,0))+ theme(aspect.ratio=1, axis.text.y = element_text(face = &quot;italic&quot;, hjust=0), axis.ticks.y = element_blank(), axis.title.y = element_text(size = 8), axis.title.x = element_text(size = 10.5), plot.margin=grid::unit(c(0,0,0,0), &quot;mm&quot;), plot.title = element_text(hjust = 0.5)) 3.3.4 CSIの算出(非交尾期のみ) 3.3.4.1 毛づくろい時間割合の算出 算出のためにデータを加工する。 ## 全期間を結合 focal_nm_IT &lt;- bind_rows(focal_19nm, focal_21nm_IT_b) ## 毛づくろい相手を表す列を追加 focal_nm_IT %&gt;% mutate(groom = ifelse(groomer == subject,groomee,groomer), groom2 = ifelse(groomer2 == subject,groomee2,groomer2)) -&gt; focal_nm_IT_b 各メスの追跡時間(総瞬間サンプリングポイント数)を算出する。 focal_nm_IT_b %&gt;% group_by(subject) %&gt;% summarise(dur = n()) %&gt;% ungroup() -&gt; focal_duration_nm_IT 各個体のITとの毛づくろい時間を算出する。 focal_nm_IT_b %&gt;% filter(groom == &quot;IT&quot;|groom2 == &quot;IT&quot;) %&gt;% group_by(subject) %&gt;% summarise(no_groom = n()) %&gt;% ungroup() -&gt; no_groom_nm_IT 最後に、毛づくろい時間割合を算出する。 left_join(focal_duration_nm_IT, no_groom_nm_IT, by = &quot;subject&quot;) %&gt;% replace_na(list(no_groom = 0)) %&gt;% mutate(prop_groom = no_groom/dur) -&gt; prop_groom_nm_IT 3.3.4.2 近接時間割合 地上採食/地上休息・毛づくろい時にITが3m以内にいた時間割合を算出する。 まずは、地上採食/地上休息・毛づくろいのデータのみを抽出する。また、ITと毛づくろいしているポイントは除外する。 focal_nm_IT_b %&gt;% filter(activity %in% c(&quot;F&quot;,&quot;R&quot;,&quot;G&quot;) &amp; T_G == &quot;G&quot;) %&gt;% select(no_focal, subject, x0_1m:x1_3m, groom, groom2) %&gt;% replace_na(list(groom = &quot;NA&quot;, groom2 = &quot;NA&quot;)) %&gt;% filter(!(groom == &quot;IT&quot;|groom2 == &quot;IT&quot;)) -&gt; focal_prox_nm_IT 分母を算出する。なお、ITと毛づくろいしていたポイントは分母に含まないものとする。 focal_prox_nm_IT %&gt;% group_by(subject) %&gt;% summarise(dur = n()) %&gt;% ungroup() -&gt; prox_duration_nm_IT ITと3m以内に近接していたポイント数を算出する。 focal_prox_nm_IT %&gt;% filter(str_detect(x0_1m, &quot;IT&quot;)|str_detect(x1_3m, &quot;IT&quot;)) %&gt;% group_by(subject) %&gt;% summarise(no_prox = n()) %&gt;% ungroup() -&gt; no_prox_nm_IT 最後に、近接時間割合を算出する。 left_join(prox_duration_nm_IT, no_prox_nm_IT, by = &quot;subject&quot;) %&gt;% replace_na(list(no_prox = 0)) %&gt;% mutate(prop_prox = no_prox/dur) -&gt; prop_prox_nm_IT 3.3.4.3 CSIの算出 それでは、上記のデータを用いてCSIを算出する。 ## 平均毛づくろい時間割合 mean_groom_nm_IT &lt;- mean(prop_groom_nm_IT$prop_groom) ## 平均近接時間割合 mean_prox_nm_IT &lt;- mean(prop_prox_nm_IT$prop_prox) ## CSIの算出 prop_groom_nm_IT %&gt;% left_join(prop_prox_nm_IT, by = &quot;subject&quot;) %&gt;% mutate(CSI_IT = ((prop_groom/mean_groom_nm_IT) + (prop_prox/mean_prox_nm_IT))/2) -&gt; CSI_nm_IT 算出した値が以下の通り。 CSI_nm_IT %&gt;% mutate(subject = fct_reorder(subject, CSI_IT)) %&gt;% ggplot(aes(x = subject, y = CSI_IT))+ geom_col(color = &quot;black&quot;, fill = &quot;white&quot;, size =0.3)+ theme_classic(base_size=12, base_family = &quot;Arial&quot;)+ xlab(&quot;&quot;)+ ylab(expression(CSI[i]))+ coord_flip(ylim = c(0,7)) + scale_y_continuous(breaks = seq(0,10, by= 1), expand= c(0,0))+ theme(aspect.ratio=1, axis.text.y = element_text(face = &quot;italic&quot;, hjust=0), axis.ticks.y = element_blank(), axis.title.y = element_text(size = 8), axis.title.x = element_text(size = 10.5), plot.margin=grid::unit(c(0,0,0,0), &quot;mm&quot;), plot.title = element_text(hjust = 0.5)) 3.3.5 CSIの算出(調査期間ごと) 3.3.5.1 毛づくろい時間割合の算出 各メスの追跡時間(総瞬間サンプリングポイント数)を調査期間ごとに算出する。 focal_all_IT_b %&gt;% group_by(subject, study_period) %&gt;% summarise(dur = n()) %&gt;% ungroup() -&gt; focal_duration_sp_IT 各個体のITとの毛づくろい時間を算出する。 focal_all_IT_b %&gt;% filter(groom == &quot;IT&quot;|groom2 == &quot;IT&quot;) %&gt;% group_by(subject, study_period) %&gt;% summarise(no_groom = n()) %&gt;% ungroup() -&gt; no_groom_sp_IT 最後に、毛づくろい時間割合を算出する。 left_join(focal_duration_sp_IT, no_groom_sp_IT, by = c(&quot;subject&quot;,&quot;study_period&quot;)) %&gt;% replace_na(list(no_groom = 0)) %&gt;% mutate(prop_groom = no_groom/dur) -&gt; prop_groom_sp_IT 3.3.5.2 近接時間割合 地上採食/地上休息・毛づくろい時にITが3m以内にいた時間割合を算出する。 調査期間ごとに分母を算出する。なお、ITと毛づくろいしていたポイントは分母に含まないものとする。 focal_prox_IT %&gt;% group_by(subject, study_period) %&gt;% summarise(dur = n()) %&gt;% ungroup() -&gt; prox_duration_sp_IT ITと3m以内に近接していたポイント数を算出する。 focal_prox_IT %&gt;% filter(str_detect(x0_1m, &quot;IT&quot;)|str_detect(x1_3m, &quot;IT&quot;)) %&gt;% group_by(subject, study_period) %&gt;% summarise(no_prox = n()) %&gt;% ungroup() -&gt; no_prox_sp_IT 最後に、近接時間割合を算出する。 left_join(prox_duration_sp_IT, no_prox_sp_IT, by = c(&quot;subject&quot;,&quot;study_period&quot;)) %&gt;% replace_na(list(no_prox = 0)) %&gt;% mutate(prop_prox = no_prox/dur) -&gt; prop_prox_sp_IT 3.3.5.3 CSIの算出 それでは、上記のデータを用いてCSIを算出する。なお、平均毛づくろい時間割合が0の調査期間は分子の左側を1とした。 ## CSIの算出 prop_groom_sp_IT %&gt;% left_join(prop_prox_sp_IT, by = c(&quot;subject&quot;,&quot;study_period&quot;)) %&gt;% group_by(study_period) %&gt;% mutate(mean_groom = mean(prop_groom), mean_prox = mean(prop_prox)) %&gt;% ungroup() %&gt;% mutate(CSI_IT = ifelse(mean_groom != 0, ((prop_groom/mean_groom) + (prop_prox/mean_prox))/2, (1 + (prop_prox/mean_prox))/2)) -&gt; CSI_sp_IT 算出した値が以下の通り。 CSI_sp_IT %&gt;% ggplot(aes(x = study_period, y = CSI_IT))+ geom_point()+ geom_line(aes(group = subject))+ theme_bw()+ facet_rep_wrap(~subject, repeat.tick.labels = TRUE)+ ylab(expression(CSI[i])) 3.4 分母をTYとIT両方の頻度の平均値にする場合 CSIを算出する際の分母を、TYとITのデータの両方を合わせた平均にします。 3.4.1 CSIの算出 算出は以下のように行えます。 ## 平均毛づくろい時間割合 mean_groom_TYIT &lt;- mean(c(prop_groom_TY$prop_groom, prop_groom_IT$prop_groom)) ## 平均近接時間割合 mean_prox_TYIT &lt;- mean(c(prop_prox_TY$prop_prox, prop_prox_IT$prop_prox)) ## CSIの算出 ### 平均値 prop_groom_TY %&gt;% left_join(prop_prox_TY, by = &quot;subject&quot;) %&gt;% mutate(CSI_TY = ((prop_groom/mean_groom_TYIT) + (prop_prox/mean_prox_TYIT))/2) -&gt; CSI_TY_combined prop_groom_IT %&gt;% left_join(prop_prox_IT, by = &quot;subject&quot;) %&gt;% mutate(CSI_IT = ((prop_groom/mean_groom_TYIT) + (prop_prox/mean_prox_TYIT))/2) -&gt; CSI_IT_combined 3.4.2 図示 図示すると以下のようになります。 CSI_TY_combined %&gt;% mutate(subject = fct_reorder(subject, CSI_TY)) %&gt;% ggplot(aes(x = subject, y = CSI_TY))+ geom_col(color = &quot;black&quot;, fill = &quot;white&quot;, size =0.3)+ theme_classic(base_size=12, base_family = &quot;Arial&quot;)+ xlab(&quot;&quot;)+ ylab(expression(paste(CSI, &quot; with &quot;, italic(TY))))+ labs(title = &quot;(a)&quot;)+ coord_flip(ylim = c(0,5.15)) + scale_y_continuous(breaks = seq(0,5.2, by= 0.5), expand= c(0,0))+ theme_bw()+ theme(aspect.ratio=1, axis.text.y = element_text(face = &quot;italic&quot;, hjust=0, family = &quot;Times New Roman&quot;), axis.text.x = element_text(family = &quot;Times New Roman&quot;), axis.ticks.y = element_blank(), axis.title.y = element_text(size = 8, family = &quot;Times New Roman&quot;), axis.title.x = element_text(size = 10.5, family = &quot;Times New Roman&quot;), plot.margin=grid::unit(c(0,0,0,0), &quot;mm&quot;), plot.title = element_text(family = &quot;Times New Roman&quot;, hjust = 0)) -&gt; p_CSI_TY_combined # ggsave(&quot;figures/p_CSI_TY_combined.tif&quot;, # p_CSI_TY_combined, width = 100, height = 100, dpi = 2000, # units = &quot;mm&quot;) CSI_IT_combined %&gt;% mutate(subject = fct_reorder(subject, CSI_IT)) %&gt;% ggplot(aes(x = subject, y = CSI_IT))+ geom_col(color = &quot;black&quot;, fill = &quot;white&quot;, size =0.3)+ theme_classic(base_size=12, base_family = &quot;Arial&quot;)+ xlab(&quot;&quot;)+ ylab(expression(paste(CSI, &quot; with &quot;, italic(IT))))+ labs(title = &quot;(b)&quot;)+ coord_flip(ylim = c(0,4)) + scale_y_continuous(breaks = seq(0,4, by= 0.5), expand= c(0,0))+ theme_bw()+ theme(aspect.ratio=1, axis.text.y = element_text(face = &quot;italic&quot;, hjust=0, family = &quot;Times New Roman&quot;), axis.text.x = element_text(family = &quot;Times New Roman&quot;), axis.ticks.y = element_blank(), axis.title.y = element_text(size = 8, family = &quot;Times New Roman&quot;), axis.title.x = element_text(size = 10.5, family = &quot;Times New Roman&quot;), plot.margin=grid::unit(c(0,0,0,0), &quot;mm&quot;), plot.title = element_text(family = &quot;Times New Roman&quot;, hjust = 0)) -&gt; p_CSI_IT_combined # ggsave(&quot;figures/p_CSI_IT_combined.tif&quot;, # p_CSI_IT_combined, width = 100, height = 100, dpi = 2000, # units = &quot;mm&quot;) p_CSI_TYIT_combined &lt;- p_CSI_TY_combined + p_CSI_IT_combined # ggsave(&quot;figures/p_CSI_TYIT_combined.tif&quot;, p_CSI_TYIT_combined, # width = 180, height = 105, units = &quot;mm&quot;, dpi = 2000) 3.5 算出に使用したメスの個体追跡データの概要 以下に、全期間のCSIを算出するのに使用した各メスの個体追跡データの総時間(総瞬間サンプリングポイント数)の情報をまとめる。 focal_duration_TY %&gt;% left_join(focal_duration_IT, by = &quot;subject&quot;) %&gt;% rename(femaleID = 1, &quot;Total points(TY)&quot; = 2, &quot;Total points (IT)&quot; = 3) %&gt;% flextable() %&gt;% colformat_double(digits=2) %&gt;% set_table_properties(layout=&quot;autofit&quot;,width = 1) %&gt;% autofit(add_w = 0.2) %&gt;% flextable::font(part = &quot;header&quot;, fontname = &quot;Times New Roman&quot;) %&gt;% flextable::font(part = &quot;body&quot;, j=1:3, fontname = &quot;Times New Roman&quot;) %&gt;% theme_zebra() %&gt;% hline_bottom() %&gt;% hline_top() %&gt;% align(j=2:3,part = &quot;all&quot;,align = &quot;center&quot;) -&gt; table_focal_duration table_focal_duration .cl-687a2662{table-layout:auto;width:100%;}.cl-68723dda{font-family:'Times New Roman';font-size:11pt;font-weight:bold;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-68723dee{font-family:'Times New Roman';font-size:11pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-6875554c{margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-68755556{margin:0;text-align:center;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-687570f4{background-color:rgba(207, 207, 207, 1.00);vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-687570fe{background-color:rgba(207, 207, 207, 1.00);vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-68757108{background-color:rgba(207, 207, 207, 1.00);vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-68757112{background-color:rgba(239, 239, 239, 1.00);vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-68757113{background-color:rgba(239, 239, 239, 1.00);vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-6875711c{background-color:rgba(239, 239, 239, 1.00);vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-6875711d{background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-6875711e{background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-6875711f{background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-68757126{background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-68757130{background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-68757131{background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}femaleIDTotal points(TY)Total points (IT)Aka2,3061,575Ako2,4591,704Hen2,6211,689Hot2,2681,603Kil2,5611,655Kit2,3021,545Koh2,4011,731Kol2,6271,715Kun2,0991,344Kur1,1201,120Mal2,4581,640Mei2,7421,727Mif1,225547Mik2,4131,717Ntr2,8001,801Tam1,4581,458Ten2,6181,726Tot2,7201,848 References Yamaguchi, T., &amp; Kazahari, N. (2022). Fission–fusion dynamics in a wild group of japanese macaques (macaca fuscata) on kinkazan island caused by the repeated separation of an alpha male being followed by females. Primates, 63(6), 575–582. "],["05_data_cleaning.html", "4 個体追跡データの加工 4.1 必要なデータの読み込み 4.2 データの加工", " 4 個体追跡データの加工 以下では、個体追跡データを分析のために加工します。 4.1 必要なデータの読み込み 以下、必要なデータを読み込みます。 ## メスを確認した時間 female_time &lt;- read_csv(&quot;../Data/data/others/female_pre_time.csv&quot;) %&gt;% mutate(date = as_date(date)) #個体の属性情報 att &lt;- read_csv(&quot;../Data/data/others/attributes_sp_over6.csv&quot;) 4.2 データの加工 4.2.1 メスの情報 まず、個体追跡データに以下のような加工を行い、新たに列を作成します。 groupID: 追跡メスがどの集団にいたか max_female: 最大メス数 no_female: 確認メス数 no_est: 発情メス数 ## 各フォーカル個体がどの集団で観察されたか female_presence_group &lt;- group_all %&gt;% pivot_longer(Kur:Yun, names_to = &quot;subject&quot;, values_to = &quot;presence&quot;) %&gt;% filter(presence == 1) %&gt;% ## 2020年11月13の2つ目の集団は除く filter(!groupID %in% c(&quot;m20_52&quot;)) %&gt;% select(date, groupID, subject) ## 各観察日の最大個体 max_female &lt;- female_time %&gt;% pivot_longer(cols = Kur:Cur, names_to = &quot;femaleID&quot;, values_to = &quot;presence&quot;) %&gt;% filter(is.na(presence)|(presence != &quot;DD&quot; &amp; presence != &quot;NS&quot;)) %&gt;% group_by(date) %&gt;% summarise(max_female = n()) ## 各観察日の確認メス数(6歳以上)と発情メス数 no_female &lt;- group_all %&gt;% select(groupID, study_period, date, Kur:Yun) %&gt;% select(-c(TY,IT, LK, KR, KM, TG)) %&gt;% pivot_longer(cols = Kur:Yun, names_to = &quot;femaleID&quot;, values_to = &quot;presence&quot;) %&gt;% left_join(att) %&gt;% ## 6歳以上の個体のみを抽出 filter(age &gt;= 6) %&gt;% left_join(female_all %&gt;% select(date, femaleID, rs2)) %&gt;% ## groupIDごとに個体数を算出 group_by(date, groupID, study_period) %&gt;% summarise(no_female = sum(presence, na.rm = TRUE), no_est = sum(rs2, na.rm = TRUE)) %&gt;% ungroup() ## 結合 focal_combined_b &lt;- focal_combined %&gt;% mutate(date = as_date(date)) %&gt;% left_join(female_presence_group, by = c(&quot;subject&quot;, &quot;date&quot;)) %&gt;% left_join(max_female, by = c(&quot;date&quot;)) %&gt;% left_join(no_female) 4.2.2 オスの情報 続いて、交尾期については追跡日に確認された群れ外オス数、オス数を追加します。 まず、生データを用いて群れ外オス数とオス数を算出します。 no_ntm_m18 &lt;- male_18m %&gt;% mutate(ntm = if_else(maleID %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;), 0, 1)) %&gt;% group_by(date) %&gt;% summarise(no_male = sum(presence, na.rm = TRUE), no_ntm = sum(ntm == 1 &amp; presence == 1, na.rm = TRUE)) no_ntm_m19 &lt;- male_19m %&gt;% mutate(ntm = if_else(maleID %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;), 0, 1)) %&gt;% group_by(date) %&gt;% summarise(no_male = sum(presence, na.rm = TRUE), no_ntm = sum(ntm == 1 &amp; presence == 1, na.rm = TRUE)) no_ntm_m20 &lt;- male_20m %&gt;% mutate(ntm = if_else(maleID %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;, &quot;KM&quot;), 0, 1)) %&gt;% group_by(date) %&gt;% summarise(no_male = sum(presence, na.rm = TRUE), no_ntm = sum(ntm == 1 &amp; presence == 1, na.rm = TRUE)) no_ntm_m21 &lt;- male_21m %&gt;% mutate(ntm = if_else(maleID %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;, &quot;KM&quot;, &quot;TG&quot;), 0, 1)) %&gt;% group_by(date) %&gt;% summarise(no_male = sum(presence, na.rm = TRUE), no_ntm = sum(ntm == 1 &amp; presence == 1, na.rm = TRUE)) sum_ntm &lt;- bind_rows(no_ntm_m18, no_ntm_m19, no_ntm_m20, no_ntm_m21) これを結合します。 focal_combined_c &lt;- focal_combined_b %&gt;% left_join(sum_ntm) 4.2.3 TYとITの確認状況 調査期間中、第一位オスのタイヨウ(TY)と第二位オスのイツモ(IT)の群れへの出入りが頻繁に観察されました。 そこで、彼らが個体追跡時にいたか否かについての列(TY、IT)を追加します。 まず、彼らが確認できた時刻に関するデータを読み込む。 TYIT_presence_time &lt;- read_excel(&quot;../Data/data/2019mating/2019mating_raw.xlsx&quot;, sheet = &quot;male_presence_long&quot;) %&gt;% mutate(study_period = &quot;m19&quot;) %&gt;% mutate(groupID = str_c(study_period,&quot;_&quot;, groupID)) %&gt;% select(maleID, date, groupID, male_presence, first, last) %&gt;% bind_rows(read_excel(&quot;../Data/data/2020mating/2020mating_raw.xlsx&quot;, sheet = &quot;male_presence_long&quot;) %&gt;% mutate(study_period = &quot;m20&quot;) %&gt;% mutate(groupID = str_c(study_period,&quot;_&quot;, groupID)) %&gt;% select(maleID, date, groupID, male_presence, first, last)) %&gt;% bind_rows(read_excel(&quot;../Data/data/2021mating/2021mating_raw.xlsx&quot;, sheet = &quot;male_presence_long&quot;) %&gt;% mutate(study_period = &quot;m21&quot;) %&gt;% mutate(groupID = str_c(study_period,&quot;_&quot;, groupID)) %&gt;% select(maleID, date, groupID, male_presence, first, last)) %&gt;% bind_rows(read_excel(&quot;../Data/data/2019nonmating/2019nonmating_raw.xlsx&quot;, sheet = &quot;male_presence_long&quot;) %&gt;% mutate(study_period = &quot;nm19&quot;) %&gt;% mutate(groupID = str_c(study_period,&quot;_&quot;, groupID)) %&gt;% select(maleID, date, groupID, male_presence, first, last)) %&gt;% bind_rows(read_excel(&quot;../Data/data/2020nonmating/2020nonmating_raw.xlsx&quot;, sheet = &quot;male_presence_long&quot;) %&gt;% mutate(study_period = &quot;nm20&quot;) %&gt;% mutate(groupID = str_c(study_period,&quot;_&quot;, groupID)) %&gt;% select(maleID, date, groupID, male_presence, first, last)) %&gt;% bind_rows(read_excel(&quot;../Data/data/2021nonmating/2021nonmating_raw.xlsx&quot;, sheet = &quot;male_presence_long&quot;) %&gt;% mutate(study_period = &quot;nm21&quot;) %&gt;% mutate(groupID = str_c(study_period,&quot;_&quot;, groupID)) %&gt;% select(maleID, date, groupID, male_presence, first, last)) %&gt;% bind_rows(read_excel(&quot;../Data/data/2022nonmating/2022nonmating_raw.xlsx&quot;, sheet = &quot;male_presence_long&quot;) %&gt;% mutate(study_period = &quot;nm22&quot;) %&gt;% mutate(groupID = str_c(study_period,&quot;_&quot;, groupID)) %&gt;% select(maleID, date, groupID, male_presence, first, last)) %&gt;% mutate(across(c(first, last), ~make_datetime(year(date), month(date), mday(date), hour(.),minute(.)))) ## 横長にする TYIT_presence_time_wide &lt;- TYIT_presence_time %&gt;% filter(maleID == &quot;TY&quot;) %&gt;% rename(first_TY = first, last_TY = last, TY = male_presence) %&gt;% select(-maleID) %&gt;% left_join(TYIT_presence_time %&gt;% filter(maleID == &quot;IT&quot;) %&gt;% rename(first_IT = first, last_IT = last, IT = male_presence) %&gt;% select(-maleID)) %&gt;% mutate(date = as_date(date)) TYIT_presence_time_wide これを利用し、個体追跡中にTYまたはITがいたと考えられるかを表す列を作成します。 TY_presence/IT_presence 1: 個体追跡開始前または個体追跡中にTYを確認、かつTYがいなくなったと思われる前に開始 0: その他 focal_combined_c %&gt;% left_join(group_all %&gt;% select(date, groupID, TY, IT)) %&gt;% left_join(TYIT_presence_time_wide %&gt;% select(-TY, -IT)) %&gt;% mutate(TY_presence = case_when( study_period == &quot;m18&quot; ~ TY, is.na(first_TY) ~ 0, start_time &gt;= first_TY &amp; start_time &lt;= last_TY ~ 1, fin_time &gt;= first_TY ~ 1, start_time &gt;= last_TY ~ 0, fin_time &lt;= first_TY ~ 0, .default = 1 )) %&gt;%  mutate(IT_presence = case_when( study_period == &quot;m18&quot; ~ IT, is.na(first_IT) ~ 0, start_time &gt;= first_IT &amp; start_time &lt;= last_IT ~ 1, fin_time &gt;= first_IT ~ 1, start_time &gt;= last_IT ~ 0, fin_time &lt;= first_IT ~ 0, .default = 1 )) -&gt; focal_combined_d 4.2.4 フォーカルを攻撃したオスのID 最後に、フォーカルが攻撃を受けた際の攻撃したオスのIDを表す列を作成します。 focal_combined_d %&gt;% ## NAになっているところを0に replace_na(list(agg_focal = 0)) %&gt;% replace_na(list(victim1 = &quot;NA&quot;, victim2 = &quot;NA&quot;, victim3 = &quot;NA&quot;, aggressor1 = &quot;NA&quot;, aggressor2 = &quot;NA&quot;, aggressor = &quot;NA&quot;)) %&gt;% mutate(if_victim1 = ifelse(agg_focal == 1 &amp; str_detect(victim1, subject), 1, 0), if_victim2 = ifelse(agg_focal == 1 &amp; str_detect(victim2, subject), 1, 0), if_victim3 = ifelse(agg_focal == 1 &amp; str_detect(victim3, subject), 1, 0)) %&gt;% mutate(aggressor_focal = case_when( if_victim1 == 1 &amp; if_victim2 == 1 &amp; if_victim3 == 1 ~ str_c(aggressor1,aggressor2,aggressor3,sep =&quot;,&quot;), if_victim1 == 1 &amp; if_victim2 == 1 ~ str_c(aggressor1, aggressor2,sep =&quot;,&quot;), if_victim1 == 1 &amp; if_victim3 == 1 ~ str_c(aggressor1, aggressor3,sep =&quot;,&quot;), if_victim2 == 1 &amp; if_victim3 == 1 ~ str_c(aggressor2, aggressor3,sep =&quot;,&quot;), if_victim1 == 1 ~ aggressor1, if_victim2 == 1 ~ aggressor2, if_victim3 == 1 ~ aggressor3, .default = NA )) %&gt;% ## aggressor2には、追跡個体が同時刻に2頭から攻撃を受けたときのみ値が入る   separate(aggressor_focal, into = c(&quot;aggressor_focal1&quot;,&quot;aggressor_focal2&quot;), sep = &quot;,&quot;) -&gt; focal_combined_final 加工したデータは以下の通り。 datatable(focal_combined_final, options = list(scrollX = 60), filter = list(position =&quot;top&quot;)) 4.2.5 フォーカルリスト フォーカル個体のリストを作成します。 focal_list &lt;- focal_combined_final %&gt;% mutate(no_focal = str_c(study_period, &quot;_&quot;, no_focal)) %&gt;% group_by(no_focal, date, subject) %&gt;% summarise(n_points = n()) %&gt;% ungroup() focal_list "],["06_aggression_injury.html", "5 オスの攻撃と怪我の関連 5.1 データの加工 5.2 分析", " 5 オスの攻撃と怪我の関連 本章では、オスから受けた攻撃の頻度と怪我の有無の関連について検討します。 5.1 データの加工 まず怪我のデータを読み込みます。 ## 怪我データの読み込み injury_m18 &lt;- read_excel(&quot;../Data/data/2018mating/2018mating_raw.xlsx&quot;, sheet = &quot;injury&quot;) injury_m19 &lt;- read_excel(&quot;../Data/data/2019mating/2019mating_raw.xlsx&quot;, sheet = &quot;injury&quot;) injury_m20 &lt;- read_excel(&quot;../Data/data/2020mating/2020mating_raw.xlsx&quot;,sheet = &quot;injury&quot;) injury_m21 &lt;- read_excel(&quot;../Data/data/2021mating/2021mating_raw.xlsx&quot;,sheet = &quot;injury&quot;) injury_nm19 &lt;- read_excel(&quot;../Data/data/2019nonmating/2019nonmating_raw.xlsx&quot;, sheet = &quot;injury&quot;) injury_nm21 &lt;- read_excel(&quot;../Data/data/2021nonmating/2021nonmating_raw.xlsx&quot;,sheet = &quot;injury&quot;) injury_nm22 &lt;- read_excel(&quot;../Data/data/2022nonmating/2022nonmating_raw.xlsx&quot;,sheet = &quot;injury&quot;) injury_all &lt;- bind_rows(injury_m18,injury_m19,injury_m20,injury_m21, injury_nm19,injury_nm21,injury_nm22) %&gt;% pivot_longer(Kur:Har, names_to = &quot;femaleID&quot;, values_to = &quot;injury&quot;) %&gt;% mutate(injury01 = ifelse(injury &gt;= 1, 1, 0)) %&gt;% mutate(date = as_date(date)) 続いて、攻撃データを加工し、各個体の被攻撃頻度を日ごとに算出します。 ### 個体ごとの被攻撃頻度 agg_each &lt;- aggression_all %&gt;% left_join(att, by = c(&quot;study_period&quot;, &quot;femaleID&quot;)) %&gt;% filter(!is.na(age)) %&gt;% group_by(date, femaleID) %&gt;% summarise(no_agg = n()) %&gt;% ungroup() %&gt;% complete(date,femaleID) %&gt;% replace_na(list(no_agg = 0)) %&gt;% mutate(study_period = str_c(&quot;m&quot;,str_sub(year(date),3,4))) %&gt;% left_join(att, by = c(&quot;study_period&quot;, &quot;femaleID&quot;)) %&gt;% ## 6歳以上を抽出 filter(!is.na(age)) ### 個体データに結合 ## 各集団で確認できたメスと集団を追跡した時間を算出 group_all_b &lt;- group_all %&gt;% mutate(date = as_date(date), duration1 = as.numeric(difftime(fin, start, units = &quot;mins&quot;)), duration2 = as.numeric(difftime(restart, suspend, units = &quot;mins&quot;)))%&gt;% mutate(duration1 = replace_na(duration1,0), duration2 = replace_na(duration2,0)) %&gt;% mutate(duration = as.numeric(duration1 - duration2)) group_all_b %&gt;% select(groupID, study_period, date, duration, Kur:Yun) %&gt;% select(-c(TY,IT, LK, KR, KM, TG)) %&gt;% pivot_longer(cols = Kur:Yun, names_to = &quot;femaleID&quot;, values_to = &quot;presence&quot;) %&gt;% left_join(att) %&gt;% filter(presence == 1 &amp; age &gt;= 6) %&gt;% filter(date &gt;= &quot;2018-10-08&quot;) %&gt;% left_join(agg_each %&gt;% select(date, femaleID, no_agg, study_period)) %&gt;% replace_na(list(no_agg = 0)) -&gt; agg_rate_each 最後に、被攻撃頻度のデータと怪我データを結合します。また、フォーカルをその日にしたか否かの列も作成します。 ## データを結合 injury_final &lt;- agg_rate_each %&gt;% left_join(injury_all, by = c(&quot;date&quot;, &quot;femaleID&quot;)) %&gt;% left_join(female_all %&gt;% select(date, femaleID, rs2), by = c(&quot;date&quot;, &quot;femaleID&quot;)) %&gt;% drop_na(injury) %&gt;% left_join(focal_list %&gt;% group_by(date, subject) %&gt;% summarise(n_points = sum(n_points)) %&gt;% ungroup() %&gt;% select(date, subject, n_points) %&gt;% rename(femaleID = subject) %&gt;% mutate(focal = 1)) %&gt;% replace_na(list(n_points = 0, focal = 0)) 以下のようになりました。 datatable(injury_final) 5.2 分析 5.2.1 交尾期と非交尾期の比較 まず、交尾期と非交尾期の怪我頻度の違いを調べます。 5.2.1.1 モデリング 分析には、十分に観察を行った日(観察時間が240分以上)のみを用います。 応答変数: 怪我が確認されたか否か(injury01) 説明変数: 季節(mating_an vs mating_es vs nonmating)、観察時間(duration) ランダム切片: メスID(femaleID) injury_analysis_season &lt;- injury_final %&gt;% filter(duration &gt;= 240) %&gt;% mutate(season = if_else(str_detect(study_period, &quot;nm&quot;), &quot;nonmating&quot;, &quot;mating&quot;)) %&gt;% mutate(season2 = case_when( season == &quot;nonmating&quot; ~ &quot;nonmating&quot;, season == &quot;mating&quot; &amp; rs2 == 1 ~ &quot;mating_es&quot;, season == &quot;mating&quot; &amp; rs2 == 0 ~ &quot;mating_an&quot;, .default = NA )) m_injury_season &lt;- brm(injury01 ~ season2 + (1|femaleID), family = bernoulli, iter = 11000, warmup = 1000, seed = 13, prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), prior(student_t(4,0,15), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;)), control=list(adapt_delta = 0.9999, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = injury_analysis_season, file = &quot;model/m_injury_season.rds&quot;) 5.2.1.2 モデルチェック まず、DHARMaパッケージ(Hartig, 2022)とDHARMa.helperパッケージ(Rodríguez-Sánchez, 2023)でモデルの前提が満たされているかを確認する。いずれのモデルも特に問題はないよう。 ## 全期間 dh_injury_season &lt;- dh_check_brms(m_injury_season, quantreg = TRUE) ゼロ過剰などの問題もない。 testZeroInflation(dh_injury_season) ## ## DHARMa zero-inflation test via comparison to expected zeros with ## simulation under H0 = fitted model ## ## data: simulationOutput ## ratioObsSim = 1, p-value = 1 ## alternative hypothesis: two.sided bayesplotパッケージ(Gabry &amp; Mahr, 2022)のpp_check関数で、事後分布からの予測分布と実測値の分布を比較しても大きな乖離はない。 ## 全期間 pp_check(m_injury_season, ndraws = 100)+ theme_bw()+ theme(aspect.ratio = 0.9) 多重共線性のチェックも行ったが、VIFに問題はない。 ## 全期間 check_collinearity(m_injury_season) ## NULL Rhatにも問題はなく、収束の問題はないよう。 data.frame(Rhat = brms::rhat(m_injury_season)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) 5.2.1.3 結果の確認 5.2.1.3.1 推定された係数 まずは、推定された係数を確認します。 5.2.1.3.2 多重比較 続いて、季節/発情の有無について多重比較を行います。いずれも有意な差があることが分かります。 emm_injury_season &lt;- emmeans(m_injury_season, ~ season2, type = &quot;response&quot;) pairs(emm_injury_season) ## contrast odds.ratio lower.HPD upper.HPD ## mating_an / mating_es 0.184 0.136 0.24 ## mating_an / nonmating 2.096 1.393 2.93 ## mating_es / nonmating 11.376 7.423 16.36 ## ## Point estimate displayed: median ## Results are back-transformed from the log odds ratio scale ## HPD interval probability: 0.95 5.2.1.4 結果の図示 最後に、結果を図示します。 injury_analysis_season %&gt;% group_by(femaleID, season2) %&gt;% summarise(prop_injury = mean(injury01)) %&gt;% mutate(season2 = fct_relevel(season2, &quot;nonmating&quot;, &quot;mating_an&quot;)) %&gt;% ggplot(aes(x = season2, y = prop_injury)) + geom_violin(bw = 0.03, scale = &quot;width&quot;)+ geom_boxplot(size = 0.5, linewidth = 0.4, width = 0.2, fill = &quot;grey&quot;, outlier.alpha = 0) + geom_point(data = emm_injury_season %&gt;% data.frame() %&gt;% mutate(season2 = fct_relevel(season2, &quot;nonmating&quot;, &quot;mating_an&quot;)), aes(y = response), size = 3, color = &quot;white&quot;) + geom_errorbar(data = emm_injury_season %&gt;% data.frame() %&gt;% mutate(season2 = fct_relevel(season2, &quot;nonmating&quot;, &quot;mating_an&quot;)), aes(y = response, ymin = lower.HPD, ymax = upper.HPD), size = 0.4, color = &quot;white&quot;, width = 0.1) + geom_signif(comparisons = list(c(&quot;nonmating&quot;, &quot;mating_es&quot;), c(&quot;nonmating&quot;, &quot;mating_an&quot;), c(&quot;mating_an&quot;, &quot;mating_es&quot;)), y_position = c(0.55, 0.1, 0.5), annotations = rep(&quot;***&quot;, 3)) + theme_bw(base_size = 12) + scale_x_discrete(labels = c(&quot;NMS&quot;, &quot;MS (anestrus)&quot;, &quot;MS (estrous)&quot;)) + labs(x = &quot;&quot;, y = &quot;Proportion of injured days (n/days)&quot;) + theme(text = element_text(family = &quot;Times New Roman&quot;), aspect.ratio = 1) -&gt; p_injury_season p_injury_season ggsave(&quot;figures/p_injury_season.tif&quot;, p_injury_season, dpi = 2000, units = &quot;mm&quot;, width = 100, height = 100) 5.2.2 被攻撃頻度と怪我の有無の関連 続いて、交尾期のデータを対象にメスの被攻撃頻度と怪我の有無の間に関連があるかを調べます。 5.2.2.1 モデリング 5.2.3 モデリング それでは、モデリングを行います。分析には、先ほどと同様に240分以上群れを追跡した日のデータのみを用います。 分布: ベルヌーイ分布 リンク関数: ロジット関数 応答変数: 怪我が確認されたか否か(injury01) 説明変数: オスからの攻撃頻度(rate_agg)、メスの発情の有無(rs2)、追跡時間(duration)、 調査期間(study_period) ランダム切片: メスID(femaleID) injury_analysis &lt;- injury_final %&gt;% filter(duration &gt;= 240) %&gt;% filter(!str_detect(study_period, &quot;nm&quot;)) %&gt;% mutate(rate_agg = no_agg*60/duration) %&gt;% mutate(rate_agg_std = standardize(rate_agg)) m_agginj &lt;- brm(injury01 ~ rate_agg_std*rs2 + study_period + (1|femaleID), family = bernoulli, iter = 11000, warmup = 1000, seed = 122, prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), prior(student_t(4,0,15), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;)), control=list(adapt_delta = 0.9999, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = injury_analysis, file = &quot;model/m_agginj.rds&quot;) 5.2.3.1 モデルチェック まず、DHARMaパッケージ(Hartig, 2022)とDHARMa.helperパッケージ(Rodríguez-Sánchez, 2023)でモデルの前提が満たされているかを確認する。いずれのモデルも特に問題はないよう。 ## 全期間 dh_agginj &lt;- dh_check_brms(m_agginj, quantreg = TRUE) ゼロ過剰などの問題もない。 testZeroInflation(dh_agginj) ## ## DHARMa zero-inflation test via comparison to expected zeros with ## simulation under H0 = fitted model ## ## data: simulationOutput ## ratioObsSim = 1.0001, p-value = 1 ## alternative hypothesis: two.sided bayesplotパッケージ(Gabry &amp; Mahr, 2022)のpp_check関数で、事後分布からの予測分布と実測値の分布を比較しても大きな乖離はない。 ## 全期間 pp_check(m_agginj, ndraws = 100)+ theme_bw()+ theme(aspect.ratio = 0.9) 多重共線性のチェックも行ったが、VIFに問題はない。 ## 全期間 check_collinearity(m_agginj) Rhatにも問題はなく、収束の問題はないよう。 data.frame(Rhat = brms::rhat(m_agginj)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) 5.2.3.2 結果の確認 5.2.3.2.1 推定された係数 まずは、推定された係数を確認します。 5.2.3.2.2 交互作用項の検討 続いて、季節/発情の有無について多重比較を行います。いずれも有意な差があることが分かります。 estimate_slopes(m_agginj, trend = &quot;rate_agg_std&quot;, by = &quot;rs2 = c(0,1)&quot;, ci_method = &quot;eti&quot;) %&gt;% data.frame() 5.2.3.3 結果の図示 predict_agginj &lt;- predict_response(m_agginj, terms = c(&quot;rate_agg_std[-0.42:16.25, by = 0.1]&quot;, &quot;rs2[0:1, by = 1]&quot;), type = &quot;fixed&quot;, margin = &quot;marginalmeans&quot;, interval = &quot;confidence&quot;, ci_method = &quot;ci&quot;, ci_level = 0.95) %&gt;% data.frame() %&gt;% rename(rate_agg_std = x, rs2 = group) %&gt;% mutate(rate_agg = rate_agg_std*sd(injury_analysis$rate_agg) + mean(injury_analysis$rate_agg)) %&gt;% mutate(rs2 = as.factor(rs2)) injury_analysis %&gt;% mutate(rs2 = as.factor(rs2)) %&gt;% ggplot(aes(x = rate_agg, y = injury01))+ geom_point(shape = &quot;|&quot;, size = 3, alpha = 0.8, aes(color = rs2)) + scale_color_nejm(labels = c(&quot;Anestrus&quot;, &quot;Estrous&quot;)) + geom_line(data = predict_agginj, aes(y = predicted, linetype = rs2), linewidth = 0.4) + geom_ribbon(data = predict_agginj, aes(y = predicted, ymax = conf.high, ymin = conf.low, fill = rs2), alpha = 0.2) + scale_fill_nejm(labels = c(&quot;Anestrus&quot;, &quot;Estrous&quot;)) + scale_linetype_manual(values = c(&quot;solid&quot;, &quot;dashed&quot;), labels = c(&quot;Anestrus&quot;, &quot;Estrous&quot;)) + theme_bw(base_size = 12) + scale_y_continuous(breaks = seq(0,1,by = 0.2)) + scale_x_continuous(breaks = seq(0,1.8, 0.2)) + labs(x = &quot;Frequency of aggression (times/h)&quot;, y = &quot;Presence of new injury&quot;, color = &quot;Estrous status&quot;, linetype = &quot;Estrous status&quot;, fill = &quot;Estrous status&quot;) + theme(text = element_text(family = &quot;Times New Roman&quot;), aspect.ratio = 1) -&gt; p_agginj_all p_agginj_all ggsave(&quot;figures/p_agginj_all.png&quot;, p_agginj_all, width = 120, height = 100, units = &quot;mm&quot;, dpi = 2000) References Gabry, J., &amp; Mahr, T. (2022). Bayesplot: Plotting for bayesian models. https://mc-stan.org/bayesplot Hartig, F. (2022). DHARMa: Residual diagnostics for hierarchical (multi-level / mixed) regression models. https://CRAN.R-project.org/package=DHARMa Rodríguez-Sánchez, F. (2023). DHARMa.helpers: Helper functions to check models not (yet) directly supported by DHARMa. "],["07_cohesion_analysis.html", "6 休息中の凝集性に影響する要因 6.1 データの加工 6.2 休息集団サイズの分析 6.3 近接個体数の分析(休息中) 6.4 近接個体数の分析(採食中)", " 6 休息中の凝集性に影響する要因 以下の分析では、どのような要因が群れ内の凝集性に影響しているかを検討します。 6.1 データの加工 まず、休息中の周辺個体数などについて算出して元データに結合します。 RG_female: 休息集団内のメス数 RG_female_plus1: 自身を含めた休息集団内のメス数 RG_est: 休息集団内の発情メス数 RG_**: それぞれのオスが休息集団内にいたか x3m_female: 3m以内のメス数 x5m_female: 5m以内のメス数 **_3m: それぞれのオスが3m以内にいるか ## 各調査期間ごとの6歳以上のメスのID adult18 &lt;- unique(female_18m %&gt;% filter(age &gt;= 6) %&gt;% .$femaleID) adult19 &lt;- unique(female_19m %&gt;% filter(age &gt;= 6) %&gt;% .$femaleID) adult20 &lt;- unique(female_20m %&gt;% filter(age &gt;= 6) %&gt;% .$femaleID) adult21 &lt;- unique(female_21m %&gt;% filter(age &gt;= 6) %&gt;% .$femaleID) ## 10m以内近接個個体名を記したデータを作成 focal_prox &lt;- focal_combined_final %&gt;% separate(x0_1m, into = str_c(&quot;x0_1m&quot;,1:11), sep = &quot;,&quot;) %&gt;% separate(x1_3m, into = str_c(&quot;x1_3m&quot;,1:15), sep = &quot;,&quot;) %&gt;% separate(x3_5m, into = str_c(&quot;x3_5m&quot;,1:16), sep = &quot;,&quot;) %&gt;% separate(x5_10m, into = str_c(&quot;x5_10m&quot;, 1:9), sep = &quot;,&quot;) %&gt;% pivot_longer(cols = x0_1m1:x5_10m9, names_to = &quot;proximity&quot;, values_to = &quot;ID&quot;) %&gt;% mutate(proximity = ifelse(str_detect(proximity,&quot;x0_1m&quot;),&quot;x0_1m&quot;, ifelse(str_detect(proximity,&quot;x1_3m&quot;),&quot;x1_3m&quot;, ifelse(str_detect(proximity,&quot;x3_5m&quot;),&quot;x3_5m&quot;, ifelse(str_detect(proximity,&quot;x5_10m&quot;),&quot;x5_10m&quot;,&quot;NA&quot;))))) %&gt;% filter(!is.na(ID)) ## 休息集団に含まれるメスの数 RG_female &lt;- focal_prox %&gt;% filter(RG == &quot;1&quot;) %&gt;% filter((study_period == &quot;m18&quot; &amp; ID %in% adult18)|(study_period == &quot;nm19&quot; &amp; ID %in% adult18)| (study_period == &quot;m19&quot; &amp; ID %in% adult19)| (study_period == &quot;m20&quot; &amp; ID %in% adult20)|(study_period == &quot;nm21&quot; &amp; ID %in% adult20)| (study_period == &quot;m21&quot; &amp; ID %in% adult21)|(study_period == &quot;nm22&quot; &amp; ID %in% adult21)) %&gt;% left_join(female_all %&gt;% select(date, femaleID, rs2), by = c(&quot;date&quot;,&quot;ID&quot; = &quot;femaleID&quot;)) %&gt;% group_by(date, no_focal, time) %&gt;% summarise(RG_female = n(), RG_est = sum(rs2, na.rm = TRUE)) %&gt;% ungroup() ## 休息集団内に各オスがいるか否か RG_TY &lt;- focal_prox %&gt;% filter(RG == &quot;1&quot;) %&gt;% select(date, no_focal, time, ID) %&gt;% filter(ID == &quot;TY&quot;) %&gt;% mutate(RG_TY = 1) %&gt;% select(-ID) RG_IT &lt;- focal_prox %&gt;% filter(RG == &quot;1&quot;) %&gt;% select(date, no_focal, time, ID) %&gt;% filter(ID == &quot;IT&quot;) %&gt;% mutate(RG_IT = 1) %&gt;% select(-ID) RG_LK &lt;- focal_prox %&gt;% filter(RG == &quot;1&quot;) %&gt;% select(date, no_focal, time, ID) %&gt;% filter(ID == &quot;LK&quot;) %&gt;% mutate(RG_LK = 1) %&gt;% select(-ID) RG_KR &lt;- focal_prox %&gt;% filter(RG == &quot;1&quot;) %&gt;% select(date, no_focal, time, ID) %&gt;% filter(ID == &quot;KR&quot;) %&gt;% mutate(RG_KR = 1) %&gt;% select(-ID) ## 3m、5m近接(相手個体の活動に依らず) focal_prox_all &lt;- focal_prox %&gt;% mutate(ID = str_replace(ID, &quot;\\\\(F\\\\)&quot;,&quot;&quot;)) %&gt;% mutate(ID = str_replace(ID, &quot;\\\\(M\\\\)&quot;,&quot;&quot;)) %&gt;% mutate(ID = str_replace(ID, &quot;\\\\(O\\\\)&quot;,&quot;&quot;)) %&gt;% mutate(ID = str_replace(ID, &quot;\\\\(N\\\\)&quot;,&quot;&quot;)) %&gt;% mutate(ID = str_replace(ID, &quot;\\\\(n\\\\)&quot;,&quot;&quot;)) %&gt;% mutate(ID = str_replace(ID, &quot;\\\\(LT\\\\)&quot;,&quot;&quot;)) %&gt;% filter((study_period == &quot;m18&quot; &amp; ID %in% adult18)|(study_period == &quot;nm19&quot; &amp; ID %in% adult18)| (study_period == &quot;m19&quot; &amp; ID %in% adult19)| (study_period == &quot;m20&quot; &amp; ID %in% adult20)|(study_period == &quot;nm21&quot; &amp; ID %in% adult20)| (study_period == &quot;m21&quot; &amp; ID %in% adult21)|(study_period == &quot;nm22&quot; &amp; ID %in% adult21)) x3m_female &lt;- focal_prox_all %&gt;% filter(proximity %in% c(&quot;x0_1m&quot;,&quot;x1_3m&quot;)) %&gt;% group_by(date, no_focal, time) %&gt;% summarise(x3m_female = n()) %&gt;% ungroup() x5m_female &lt;- focal_prox_all %&gt;% filter(proximity %in% c(&quot;x0_1m&quot;,&quot;x1_3m&quot;,&quot;x3_5m&quot;)) %&gt;% group_by(date, no_focal, time) %&gt;% summarise(x5m_female = n()) %&gt;% ungroup() ## 元データに結合 focal_combined_prox &lt;- focal_combined_final %&gt;% left_join(RG_female, by = c(&quot;date&quot;,&quot;no_focal&quot;,&quot;time&quot;)) %&gt;% left_join(x3m_female, by = c(&quot;date&quot;,&quot;no_focal&quot;,&quot;time&quot;)) %&gt;% left_join(x5m_female, by = c(&quot;date&quot;,&quot;no_focal&quot;,&quot;time&quot;)) %&gt;% left_join(RG_TY, by = c(&quot;date&quot;,&quot;no_focal&quot;,&quot;time&quot;)) %&gt;% left_join(RG_IT, by = c(&quot;date&quot;,&quot;no_focal&quot;,&quot;time&quot;)) %&gt;% left_join(RG_LK, by = c(&quot;date&quot;,&quot;no_focal&quot;,&quot;time&quot;)) %&gt;% left_join(RG_KR, by = c(&quot;date&quot;,&quot;no_focal&quot;,&quot;time&quot;)) %&gt;% replace_na(list(RG_female = 0, RG_est = 0, x3m_female = 0, x5m_female =0, RG_TY = 0, RG_IT = 0, RG_LK = 0, RG_KR = 0)) %&gt;% replace_na(list(x0_1m = &quot;NA&quot;,x1_3m = &quot;NA&quot;, x3_5m = &quot;NA&quot;, x5_10m = &quot;NA&quot;)) %&gt;% ## 自身を含んだ休息集団サイズ mutate(RG_female_plus1 = RG_female + 1) %&gt;% ## オスとの近接情報を追加 mutate(TY_3m = ifelse(str_detect(x0_1m,&quot;TY&quot;)|str_detect(x1_3m,&quot;TY&quot;),1,0), IT_3m = ifelse(str_detect(x0_1m,&quot;IT&quot;)|str_detect(x1_3m,&quot;IT&quot;),1,0), KR_3m = ifelse(str_detect(x0_1m,&quot;KR&quot;)|str_detect(x1_3m,&quot;KR&quot;),1,0), LK_3m = ifelse(str_detect(x0_1m,&quot;LK&quot;)|str_detect(x1_3m,&quot;LK&quot;),1,0)) 続いて、その日群れ内にいた血縁個体数を計算し、結合します。 kin &lt;- read_csv(&quot;../Data/data/others/kin.csv&quot;) female_presence &lt;- group_all %&gt;% select(groupID, study_period, date, Kur:Yun) %&gt;% select(-c(TY,IT, LK, KR, KM, TG)) %&gt;% pivot_longer(cols = Kur:Yun, names_to = &quot;femaleID&quot;, values_to = &quot;presence&quot;) %&gt;% left_join(att) %&gt;% ## 6歳以上の個体のみを抽出 filter(age &gt;= 6, presence == 1) focal_numkin &lt;- focal_combined_final %&gt;% distinct(study_period, date, groupID, no_focal, subject) %&gt;% left_join(female_presence %&gt;% select(date, groupID, femaleID), by = c(&quot;date&quot;, &quot;groupID&quot;)) %&gt;% filter(subject != femaleID) %&gt;% left_join(kin, by = c(&quot;subject&quot; = &quot;femaleID&quot;, &quot;femaleID&quot; = &quot;femaleID2&quot;)) %&gt;% mutate(kin = ifelse(kin &gt;= 0.0625,1,0)) %&gt;% group_by(no_focal, date, subject) %&gt;% summarise(no_kin = sum(kin)) %&gt;% ungroup() focal_combined_prox %&gt;% left_join(focal_numkin, by = c(&quot;no_focal&quot;,&quot;date&quot;,&quot;subject&quot;)) -&gt; focal_combined_prox_b 続いて、TY、ITとの親密度(CSI)の情報も結合します。 focal_combined_prox_b %&gt;% left_join(CSI_TY_combined %&gt;% select(subject, CSI_TY)) %&gt;% left_join(CSI_IT_combined %&gt;% select(subject, CSI_IT)) -&gt; focal_combined_prox_c 最後に、その日観察したオトナメスへの攻撃頻度も追加します。 ### 6歳以上への攻撃のみ aggression_all %&gt;% mutate(femaleID = str_replace_all(femaleID, &quot;\\\\?&quot;,&quot;&quot;)) %&gt;% left_join(att, by = c(&quot;femaleID&quot;, &quot;study_period&quot;)) %&gt;% ## 確実に被攻撃個体が6歳以上であるものを抽出 filter(age &gt;= 6 | str_detect(femaleID,&quot;multi|many|Multi|KunTrt|Ako,Kil&quot;)) %&gt;% group_by(date) %&gt;% summarise(no_agg = length(unique(no))) %&gt;% ungroup() %&gt;% filter(date &gt;= &quot;2018-10-08&quot;) -&gt; no_agg_6yo focal_combined_prox_c %&gt;% left_join(group_all_b %&gt;% select(groupID, date, duration)) %&gt;% left_join(no_agg_6yo, by = &quot;date&quot;) %&gt;% mutate(rate_agg_6yo = no_agg*60/duration) %&gt;% replace_na(list(rate_agg_6yo = 0)) %&gt;% left_join(female_all %&gt;% select(date, femaleID, rs2), by = c(&quot;subject&quot; = &quot;femaleID&quot;, &quot;date&quot;)) -&gt; focal_combined_prox_final 作成したデータは以下の通り。 focal_combined_prox_final 6.2 休息集団サイズの分析 ここでは、TYやITの有無を含む様々な要因が個体追跡中の休息集団サイズ(正確には、休息集団内のメス数)に影響するかを検討します。 6.2.1 交尾期(非発情メス) 6.2.1.1 データの加工 まず、非発情メスについて分析を行うためのデータを作成します。連続変数は標準化します。 休息ポイント数が10以上の個体追跡セッションのみを使用 ハドリングのポイントは除去 地上休息のみを含む cohesion_data_an &lt;- focal_combined_prox_final %&gt;% mutate(rate_female = no_female/max_female) %&gt;% filter(rs2 == 0) %&gt;% replace_na(list(hud = 0)) %&gt;% filter(hud != &quot;1&quot;) %&gt;% filter(RG == 1 &amp; T_G == &quot;G&quot;) %&gt;% group_by(date, no_focal, subject, study_period, rate_agg_6yo, no_ntm, no_est, no_male, no_female, TY_presence, no_kin, IT_presence, CSI_TY) %&gt;% summarise(sum_RG = sum(RG_female_plus1), n = n()) %&gt;% ungroup() %&gt;% mutate(TY_presence = as.factor(TY_presence), IT_presence = as.factor(IT_presence)) %&gt;% filter(study_period != &quot;m18&quot;) %&gt;% filter(n &gt;= 10) %&gt;% mutate(ntm_std = standardize(no_ntm), male_std = standardize(no_male), est_std = standardize(no_est), kin_std = standardize(no_kin), female_std = standardize(no_female), rate_agg_std = standardize(rate_agg_6yo), CSI_TY_std = standardize(CSI_TY), mean_RG = sum_RG/n) cohesion_data_an 共変量と応答変数(平均休息集団サイズ)の関連を図示すると以下のようになります。 cohesion_data_an %&gt;% pivot_longer(cols = c(no_ntm, no_est, no_female, rate_agg_6yo, kin_std, CSI_TY), names_to = &quot;type&quot;, values_to = &quot;value&quot;) %&gt;% ggplot(aes(x = value, y = mean_RG)) + geom_point(shape = 1) + facet_rep_wrap(~ type, scales = &quot;free&quot;) + theme_bw(base_size = 12) + theme(aspect.ratio = 1) + labs(x = &quot;&quot;, y = &quot;Mean resting group size&quot;) 6.2.1.2 モデリング それでは、モデリングを行います。以下のように行いました。連続変数は標準化しています。また、ITの効果を見る際には、2021年交尾期を除くモデルを作成しました。 応答変数: log(平均休息集団サイズ(メスのみ)) 分布: Studentのt分布 説明変数: TYの在不在(TY_presence)、ITの在不在(IT_presence)、群れ外オス数(ntm_std)、集団内の発情メス数(est_std)、集団内のメス数(female_std)、集団内の血縁メス数(kin_est)、調査期間(study_period) ランダム切片: subject ## 2019~2021年 m_cohesion_an &lt;- brm(log(mean_RG) ~ TY_presence + IT_presence + ntm_std + est_std + female_std + kin_std + study_period + (1|subject), family = student, iter = 11000, warmup = 1000, seed = 123, prior = c(prior(student_t(4,0,5), class = &quot;b&quot;), prior(student_t(4,0,10), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;), prior(student_t(4,0,10), class = &quot;nu&quot;), prior(student_t(4,0,10), class = &quot;sigma&quot;)), control = list(adapt_delta = 0.99, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = cohesion_data_an, file = &quot;model/m_cohesion_an.rds&quot;) ## 2019~2020年 cohesion_data_an_bf21 &lt;- cohesion_data_an %&gt;% filter(study_period != &quot;m21&quot;) %&gt;% mutate(ntm_std = standardize(no_ntm), male_std = standardize(no_male), est_std = standardize(no_est), kin_std = standardize(no_kin), female_std = standardize(no_female), rate_agg_std = standardize(rate_agg_6yo), CSI_TY_std = standardize(CSI_TY), mean_RG = sum_RG/n) m_cohesion_an_bf21 &lt;- brm(log(mean_RG) ~ TY_presence + IT_presence + ntm_std + est_std + female_std + kin_std + study_period + (1|subject), family = student, iter = 11000, warmup = 1000, seed = 123, prior = c(prior(student_t(4,0,5), class = &quot;b&quot;), prior(student_t(4,0,10), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;)), control = list(adapt_delta = 0.99, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = cohesion_data_an_bf21, file = &quot;model/m_cohesion_an_bf21.rds&quot;) 6.2.1.3 モデルチェック まず、DHARMaパッケージ(Hartig, 2022)とDHARMa.helperパッケージ(Rodríguez-Sánchez, 2023)でモデルの前提が満たされているかを確認します。 ## 全期間 dh_cohesion_an &lt;- dh_check_brms(m_cohesion_an, quantreg = TRUE) ## 21年より前 dh_cohesion_an_bf21 &lt;- dh_check_brms(m_cohesion_an_bf21, quantreg = TRUE) 多重共線性の問題もありません。 ## 全期間 check_collinearity(m_cohesion_an) ## 21年より前 check_collinearity(m_cohesion_an_bf21) bayesplotパッケージ(Gabry &amp; Mahr, 2022)のpp_check関数で、事後分布からの予測分布と実測値の分布を比較しても大きな乖離はない。 ## 全期間 pp_check(m_cohesion_an, ndraws = 100)+ theme_bw()+ theme(aspect.ratio = 0.9) ## 21年より前 pp_check(m_cohesion_an_bf21, ndraws = 100)+ theme_bw()+ theme(aspect.ratio = 0.9) Rhatにも問題はなく、収束の問題はないよう。 data.frame(Rhat = brms::rhat(m_cohesion_an)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) data.frame(Rhat = brms::rhat(m_cohesion_an_bf21)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) 6.2.1.4 結果の確認 まずは、全期間のデータを用いたモデルについてみる。太字になっている変数は95%確信区間が0をまたいでおらず、有意な影響があるといえる。 続いて、2021年のデータを除いたモデルについて確認する。 6.2.1.5 結果の図示 最後に、結果の図示をします。 まず、TYの有無についてです。 emm_cohesion_an_TY &lt;- emmeans(m_cohesion_an, ~TY_presence) cohesion_data_an %&gt;% ggplot(aes(x = TY_presence, y = log(mean_RG))) + geom_violin(bw = 0.2, scale = &quot;width&quot;) + geom_boxplot(size = 0.5, linewidth = 0.4, width = 0.2, fill = &quot;grey&quot;, outlier.alpha = 0) + geom_point(data = emm_cohesion_an_TY %&gt;% data.frame() %&gt;% mutate(TY_presence = as.factor(TY_presence)), aes(y = emmean), size = 3, color = &quot;white&quot;) + geom_errorbar(data = emm_cohesion_an_TY %&gt;% data.frame() %&gt;% mutate(TY_presence = as.factor(TY_presence)), aes(y = emmean, ymin = lower.HPD, ymax = upper.HPD), size = 0.4, color = &quot;white&quot;, width = 0.1) + geom_signif(comparisons = list(c(&quot;0&quot;, &quot;1&quot;)), y_position = 2.5, annotations = &quot;***&quot;) + theme_bw(base_size = 12) + scale_x_discrete(labels = c(&quot;*TY* absent&quot;, &quot;*TY* present&quot;)) + labs(x = &quot;&quot;, y = &quot;log(mean resting group size)&quot;) + theme(text = element_text(family = &quot;Times New Roman&quot;), axis.text.x = element_markdown(), aspect.ratio = 1) -&gt; p_cohesion_an_TY p_cohesion_an_TY ggsave(&quot;figures/p_cohesion_an_TY.tif&quot;, p_cohesion_an_TY, dpi = 2000, units = &quot;mm&quot;, width = 100, height = 100) 続いて、ITについてです。 emm_cohesion_an_IT &lt;- emmeans(m_cohesion_an_bf21, ~IT_presence) cohesion_data_an_bf21 %&gt;% ggplot(aes(x = IT_presence, y = log(mean_RG))) + geom_violin(bw = 0.2, scale = &quot;width&quot;) + geom_boxplot(size = 0.5, linewidth = 0.4, width = 0.2, fill = &quot;grey&quot;, outlier.alpha = 0) + geom_point(data = emm_cohesion_an_IT %&gt;% data.frame() %&gt;% mutate(IT_presence = as.factor(IT_presence)), aes(y = emmean), size = 3, color = &quot;white&quot;) + geom_errorbar(data = emm_cohesion_an_IT %&gt;% data.frame() %&gt;% mutate(IT_presence = as.factor(IT_presence)), aes(y = emmean, ymin = lower.HPD, ymax = upper.HPD), size = 0.4, color = &quot;white&quot;, width = 0.1) + theme_bw(base_size = 12) + scale_x_discrete(labels = c(&quot;*IT* absent&quot;, &quot;*IT* present&quot;)) + labs(x = &quot;&quot;, y = &quot;log(mean resting group size)&quot;) + theme(text = element_text(family = &quot;Times New Roman&quot;), axis.text.x = element_markdown(), aspect.ratio = 1) -&gt; p_cohesion_an_IT p_cohesion_an_IT ggsave(&quot;figures/p_cohesion_an_IT.tif&quot;, p_cohesion_an_IT, dpi = 2000, units = &quot;mm&quot;, width = 100, height = 100) 6.2.2 非交尾期 6.2.2.1 データの加工 続いて、非交尾期について分析を行うためのデータを作成します。連続変数は標準化します。 休息ポイント数が10以上の個体追跡セッションのみを使用 ハドリングのポイントは除去 地上休息のみを含む cohesion_data_nm &lt;- focal_combined_prox_final %&gt;% mutate(rate_female = no_female/max_female) %&gt;% filter(str_detect(study_period, &quot;nm&quot;)) %&gt;% replace_na(list(hud = 0)) %&gt;% filter(hud != &quot;1&quot;) %&gt;% filter(RG == 1 &amp; T_G == &quot;G&quot;) %&gt;% group_by(date, no_focal, subject, study_period, no_female, TY_presence, no_kin, IT_presence) %&gt;% summarise(sum_RG = sum(RG_female_plus1), n = n()) %&gt;% ungroup() %&gt;% mutate(TY_presence = as.factor(TY_presence), IT_presence = as.factor(IT_presence)) %&gt;% filter(study_period != &quot;m18&quot;) %&gt;% filter(n &gt;= 10) %&gt;% mutate(kin_std = standardize(no_kin), female_std = standardize(no_female), mean_RG = sum_RG/n) cohesion_data_nm 共変量と応答変数(平均休息集団サイズ)の関連を図示すると以下のようになります。 cohesion_data_nm %&gt;% pivot_longer(cols = c(no_female, no_kin), names_to = &quot;type&quot;, values_to = &quot;value&quot;) %&gt;% ggplot(aes(x = value, y = mean_RG)) + geom_point(shape = 1) + facet_rep_wrap(~ type, scales = &quot;free&quot;) + theme_bw(base_size = 12) + theme(aspect.ratio = 1) + labs(x = &quot;&quot;, y = &quot;Mean resting group size&quot;) 6.2.2.2 モデリング それでは、モデリングを行います。以下のように行いました。連続変数は標準化しています。また、ITの効果を見る際には、2021年交尾期を除くモデルを作成しました。 応答変数: log(平均休息集団サイズ(メスのみ)) 分布: Studentのt分布 説明変数: TYの在不在(TY_presence)、ITの在不在(IT_presence)、群れ外オス数(ntm_std)、集団内の発情メス数(est_std)、集団内のメス数(female_std)、集団内の血縁メス数(kin_est)、調査期間(study_period) ランダム切片: subject ## 2019~2021年 m_cohesion_nm &lt;- brm(log(mean_RG) ~ TY_presence + kin_std + study_period + (1|subject), family = student, iter = 11000, warmup = 1000, seed = 123, prior = c(prior(student_t(4,0,5), class = &quot;b&quot;), prior(student_t(4,0,10), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;), prior(student_t(4,0,10), class = &quot;nu&quot;), prior(student_t(4,0,10), class = &quot;sigma&quot;)), control = list(adapt_delta = 0.99, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = cohesion_data_nm, file = &quot;model/m_cohesion_nm.rds&quot;) ## 2019~2020年 cohesion_data_nm_bf21 &lt;- cohesion_data_nm %&gt;% filter(study_period != &quot;m22&quot;) %&gt;% mutate(kin_std = standardize(no_kin), female_std = standardize(no_female), mean_RG = sum_RG/n) m_cohesion_nm_bf21 &lt;- brm(log(mean_RG) ~ TY_presence + kin_std + study_period + (1|subject), family = student, iter = 11000, warmup = 1000, seed = 123, prior = c(prior(student_t(4,0,5), class = &quot;b&quot;), prior(student_t(4,0,10), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;)), control = list(adapt_delta = 0.99, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = cohesion_data_nm_bf21, file = &quot;model/m_cohesion_nm_bf21.rds&quot;) 6.2.2.3 モデルチェック まず、DHARMaパッケージ(Hartig, 2022)とDHARMa.helperパッケージ(Rodríguez-Sánchez, 2023)でモデルの前提が満たされているかを確認します。 ## 全期間 dh_cohesion_nm &lt;- dh_check_brms(m_cohesion_nm, quantreg = TRUE) ## 21年より前 dh_cohesion_nm_bf21 &lt;- dh_check_brms(m_cohesion_nm_bf21, quantreg = TRUE) 多重共線性の問題もありません。 ## 全期間 check_collinearity(m_cohesion_nm) ## 21年より前 check_collinearity(m_cohesion_nm_bf21) bayesplotパッケージ(Gabry &amp; Mahr, 2022)のpp_check関数で、事後分布からの予測分布と実測値の分布を比較しても大きな乖離はない。 ## 全期間 pp_check(m_cohesion_nm, ndraws = 100)+ theme_bw()+ theme(aspect.ratio = 0.9) ## 21年より前 pp_check(m_cohesion_nm_bf21, ndraws = 100)+ theme_bw()+ theme(aspect.ratio = 0.9) Rhatにも問題はなく、収束の問題はないよう。 data.frame(Rhat = brms::rhat(m_cohesion_nm)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) data.frame(Rhat = brms::rhat(m_cohesion_nm_bf21)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) 6.2.2.4 結果の確認 まずは、全期間のデータを用いたモデルについてみる。太字になっている変数は95%確信区間が0をまたいでおらず、有意な影響があるといえる。 続いて、2021年のデータを除いたモデルについて確認する。 6.2.2.5 結果の図示 最後に、結果の図示をします。 まず、TYの有無についてです。 emm_cohesion_nm_TY &lt;- emmeans(m_cohesion_nm, ~TY_presence) cohesion_data_nm %&gt;% ggplot(aes(x = TY_presence, y = log(mean_RG))) + geom_violin(bw = 0.2, scale = &quot;width&quot;) + geom_boxplot(size = 0.5, linewidth = 0.4, width = 0.2, fill = &quot;grey&quot;, outlier.alpha = 0) + geom_point(data = emm_cohesion_nm_TY %&gt;% data.frame() %&gt;% mutate(TY_presence = as.factor(TY_presence)), aes(y = emmean), size = 3, color = &quot;white&quot;) + geom_errorbar(data = emm_cohesion_nm_TY %&gt;% data.frame() %&gt;% mutate(TY_presence = as.factor(TY_presence)), aes(y = emmean, ymin = lower.HPD, ymax = upper.HPD), size = 0.4, color = &quot;white&quot;, width = 0.1) + theme_bw(base_size = 12) + scale_x_discrete(labels = c(&quot;*TY* absent&quot;, &quot;*TY* present&quot;)) + labs(x = &quot;&quot;, y = &quot;log(mean resting group size)&quot;) + theme(text = element_text(family = &quot;Times New Roman&quot;), axis.text.x = element_markdown(), aspect.ratio = 1) -&gt; p_cohesion_nm_TY p_cohesion_nm_TY ggsave(&quot;figures/p_cohesion_nm_TY.tif&quot;, p_cohesion_nm_TY, dpi = 2000, units = &quot;mm&quot;, width = 100, height = 100) 6.3 近接個体数の分析(休息中) ここでは、TYやITの有無を含む様々な要因が個体追跡中の周辺メス数に影響するかを検討します。 6.3.1 交尾期(非発情メス) 6.3.1.1 データの加工 まず、非発情メスについて分析を行うためのデータを作成します。連続変数は標準化します。 休息ポイント数が10以上の個体追跡セッションのみを使用 ハドリングのポイントは除去 地上休息のみを含む prox_data_an_RG &lt;- focal_combined_prox_final %&gt;% mutate(rate_female = no_female/max_female) %&gt;% filter(rs2 == 0) %&gt;% replace_na(list(hud = 0)) %&gt;% filter(hud != &quot;1&quot;) %&gt;% filter(RG == 1 &amp; T_G == &quot;G&quot;) %&gt;% group_by(date, no_focal, subject, study_period, rate_agg_6yo, no_ntm, no_est, no_male, no_female, TY_presence, no_kin, IT_presence, CSI_TY) %&gt;% summarise(sum_prox = sum(x3m_female + 1), n = n()) %&gt;% ungroup() %&gt;% mutate(TY_presence = as.factor(TY_presence), IT_presence = as.factor(IT_presence)) %&gt;% filter(study_period != &quot;m18&quot;) %&gt;% filter(n &gt;= 10) %&gt;% mutate(ntm_std = standardize(no_ntm), male_std = standardize(no_male), est_std = standardize(no_est), kin_std = standardize(no_kin), female_std = standardize(no_female), rate_agg_std = standardize(rate_agg_6yo), CSI_TY_std = standardize(CSI_TY), mean_prox = sum_prox/n) prox_data_an_RG 共変量と応答変数(平均休息集団サイズ)の関連を図示すると以下のようになります。 prox_data_an_RG %&gt;% pivot_longer(cols = c(no_ntm, no_est, no_female, rate_agg_6yo, kin_std, CSI_TY), names_to = &quot;type&quot;, values_to = &quot;value&quot;) %&gt;% ggplot(aes(x = value, y = mean_prox)) + geom_point(shape = 1) + facet_rep_wrap(~ type, scales = &quot;free&quot;) + theme_bw(base_size = 12) + theme(aspect.ratio = 1) + labs(x = &quot;&quot;, y = &quot;Mean resting group size&quot;) 6.3.1.2 モデリング それでは、モデリングを行います。以下のように行いました。連続変数は標準化しています。また、ITの効果を見る際には、2021年交尾期を除くモデルを作成しました。 応答変数: log(平均休息集団サイズ(メスのみ)) 分布: Studentのt分布 説明変数: TYの在不在(TY_presence)、ITの在不在(IT_presence)、群れ外オス数(ntm_std)、集団内の発情メス数(est_std)、集団内のメス数(female_std)、集団内の血縁メス数(kin_est)、調査期間(study_period) ランダム切片: subject ## 2019~2021年 m_prox_an_RG &lt;- brm(log(mean_prox) ~ TY_presence + IT_presence + ntm_std + est_std + female_std + kin_std + study_period + (1|subject) + (1|date), family = student, iter = 11000, warmup = 1000, seed = 123, prior = c(prior(student_t(4,0,5), class = &quot;b&quot;), prior(student_t(4,0,10), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;), prior(student_t(4,0,10), class = &quot;nu&quot;), prior(student_t(4,0,10), class = &quot;sigma&quot;)), control = list(adapt_delta = 0.99, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = prox_data_an_RG, file = &quot;model/m_prox_an_RG.rds&quot;) ## 2019~2020年 prox_data_an_RG_bf21 &lt;- prox_data_an_RG %&gt;% filter(study_period != &quot;m21&quot;) %&gt;% mutate(ntm_std = standardize(no_ntm), male_std = standardize(no_male), est_std = standardize(no_est), kin_std = standardize(no_kin), female_std = standardize(no_female), rate_agg_std = standardize(rate_agg_6yo), CSI_TY_std = standardize(CSI_TY), mean_prox = sum_prox/n) m_prox_an_RG_bf21 &lt;- brm(log(mean_prox) ~ TY_presence + IT_presence + ntm_std + est_std + female_std + kin_std + study_period + (1|subject), family = student, iter = 11000, warmup = 1000, seed = 123, prior = c(prior(student_t(4,0,5), class = &quot;b&quot;), prior(student_t(4,0,10), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;)), control = list(adapt_delta = 0.99, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = prox_data_an_RG_bf21, file = &quot;model/m_prox_an_RG_bf21.rds&quot;) 6.3.1.3 モデルチェック まず、DHARMaパッケージ(Hartig, 2022)とDHARMa.helperパッケージ(Rodríguez-Sánchez, 2023)でモデルの前提が満たされているかを確認します。 ## 全期間 dh_prox_an_RG &lt;- dh_check_brms(m_prox_an_RG, quantreg = TRUE) ## 21年より前 dh_prox_an_RG_bf21 &lt;- dh_check_brms(m_prox_an_RG_bf21, quantreg = TRUE) 多重共線性の問題もありません。 ## 全期間 check_collinearity(m_prox_an_RG) ## 21年より前 check_collinearity(m_prox_an_RG_bf21) bayesplotパッケージ(Gabry &amp; Mahr, 2022)のpp_check関数で、事後分布からの予測分布と実測値の分布を比較しても大きな乖離はない。 ## 全期間 pp_check(m_prox_an_RG, ndraws = 100)+ theme_bw()+ theme(aspect.ratio = 0.9) ## 21年より前 pp_check(m_prox_an_RG_bf21, ndraws = 100)+ theme_bw()+ theme(aspect.ratio = 0.9) Rhatにも問題はなく、収束の問題はないよう。 data.frame(Rhat = brms::rhat(m_prox_an_RG)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) data.frame(Rhat = brms::rhat(m_prox_an_RG_bf21)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) 6.3.1.4 結果の確認 まずは、全期間のデータを用いたモデルについてみる。太字になっている変数は95%確信区間が0をまたいでおらず、有意な影響があるといえる。 続いて、2021年のデータを除いたモデルについて確認する。 6.3.1.5 結果の図示 最後に、結果の図示をします。 まず、TYの有無についてです。 emm_prox_an_RG_TY &lt;- emmeans(m_prox_an_RG, ~TY_presence) prox_data_an_RG %&gt;% ggplot(aes(x = TY_presence, y = log(mean_prox))) + geom_violin(bw = 0.2, scale = &quot;width&quot;) + geom_boxplot(size = 0.5, linewidth = 0.4, width = 0.2, fill = &quot;grey&quot;, outlier.alpha = 0) + geom_point(data = emm_prox_an_RG_TY %&gt;% data.frame() %&gt;% mutate(TY_presence = as.factor(TY_presence)), aes(y = emmean), size = 3, color = &quot;white&quot;) + geom_errorbar(data = emm_prox_an_RG_TY %&gt;% data.frame() %&gt;% mutate(TY_presence = as.factor(TY_presence)), aes(y = emmean, ymin = lower.HPD, ymax = upper.HPD), size = 0.4, color = &quot;white&quot;, width = 0.1) + geom_signif(comparisons = list(c(&quot;0&quot;, &quot;1&quot;)), y_position = 2.1, annotations = &quot;***&quot;) + theme_bw(base_size = 12) + scale_x_discrete(labels = c(&quot;*TY* absent&quot;, &quot;*TY* present&quot;)) + labs(x = &quot;&quot;, y = &quot;log(mean no. of females within 3m)&quot;) + theme(text = element_text(family = &quot;Times New Roman&quot;), axis.text.x = element_markdown(), aspect.ratio = 1) -&gt; p_prox_an_RG_TY p_prox_an_RG_TY ggsave(&quot;figures/p_prox_an_RG_TY.tif&quot;, p_prox_an_RG_TY, dpi = 2000, units = &quot;mm&quot;, width = 100, height = 100) 続いて、ITについてです。 emm_prox_an_RG_IT &lt;- emmeans(m_prox_an_RG_bf21, ~IT_presence) prox_data_an_RG_bf21 %&gt;% ggplot(aes(x = IT_presence, y = log(mean_prox))) + geom_violin(bw = 0.2, scale = &quot;width&quot;) + geom_boxplot(size = 0.5, linewidth = 0.4, width = 0.2, fill = &quot;grey&quot;, outlier.alpha = 0) + geom_point(data = emm_prox_an_RG_IT %&gt;% data.frame() %&gt;% mutate(IT_presence = as.factor(IT_presence)), aes(y = emmean), size = 3, color = &quot;white&quot;) + geom_errorbar(data = emm_prox_an_RG_IT %&gt;% data.frame() %&gt;% mutate(IT_presence = as.factor(IT_presence)), aes(y = emmean, ymin = lower.HPD, ymax = upper.HPD), size = 0.4, color = &quot;white&quot;, width = 0.1) + theme_bw(base_size = 12) + scale_x_discrete(labels = c(&quot;*IT* absent&quot;, &quot;*IT* present&quot;)) + labs(x = &quot;&quot;, y = &quot;log(mean resting group size)&quot;) + theme(text = element_text(family = &quot;Times New Roman&quot;), axis.text.x = element_markdown(), aspect.ratio = 1) -&gt; p_prox_an_RG_IT p_prox_an_RG_IT ggsave(&quot;figures/p_prox_an_RG_IT.tif&quot;, p_prox_an_RG_IT, dpi = 2000, units = &quot;mm&quot;, width = 100, height = 100) 6.3.2 非交尾期 6.3.2.1 データの加工 続いて、非交尾期について分析を行うためのデータを作成します。連続変数は標準化します。 休息ポイント数が10以上の個体追跡セッションのみを使用 ハドリングのポイントは除去 地上休息のみを含む prox_data_nm_RG &lt;- focal_combined_prox_final %&gt;% mutate(rate_female = no_female/max_female) %&gt;% filter(str_detect(study_period, &quot;nm&quot;)) %&gt;% replace_na(list(hud = 0)) %&gt;% filter(hud != &quot;1&quot;) %&gt;% filter(RG == 1 &amp; T_G == &quot;G&quot;) %&gt;% group_by(date, no_focal, subject, study_period, no_female, TY_presence, no_kin, IT_presence) %&gt;% summarise(sum_prox = sum(x3m_female + 1), n = n()) %&gt;% ungroup() %&gt;% mutate(TY_presence = as.factor(TY_presence), IT_presence = as.factor(IT_presence)) %&gt;% filter(study_period != &quot;m18&quot;) %&gt;% filter(n &gt;= 10) %&gt;% mutate(kin_std = standardize(no_kin), female_std = standardize(no_female), mean_prox = sum_prox/n) prox_data_nm_RG 共変量と応答変数(平均休息集団サイズ)の関連を図示すると以下のようになります。 prox_data_nm_RG %&gt;% pivot_longer(cols = c(no_female, no_kin), names_to = &quot;type&quot;, values_to = &quot;value&quot;) %&gt;% ggplot(aes(x = value, y = mean_prox)) + geom_point(shape = 1) + facet_rep_wrap(~ type, scales = &quot;free&quot;) + theme_bw(base_size = 12) + theme(aspect.ratio = 1) + labs(x = &quot;&quot;, y = &quot;Mean resting group size&quot;) 6.3.2.2 モデリング それでは、モデリングを行います。以下のように行いました。連続変数は標準化しています。また、ITの効果を見る際には、2021年交尾期を除くモデルを作成しました。 応答変数: log(平均休息集団サイズ(メスのみ)) 分布: Studentのt分布 説明変数: TYの在不在(TY_presence)、ITの在不在(IT_presence)、群れ外オス数(ntm_std)、集団内の発情メス数(est_std)、集団内のメス数(female_std)、集団内の血縁メス数(kin_est)、調査期間(study_period) ランダム切片: subject ## 2019~2021年 m_prox_nm_RG &lt;- brm(log(mean_prox) ~ TY_presence + kin_std + study_period + (1|subject), family = student, iter = 11000, warmup = 1000, seed = 123, prior = c(prior(student_t(4,0,5), class = &quot;b&quot;), prior(student_t(4,0,10), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;), prior(student_t(4,0,10), class = &quot;nu&quot;), prior(student_t(4,0,10), class = &quot;sigma&quot;)), control = list(adapt_delta = 0.99, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = prox_data_nm_RG, file = &quot;model/m_prox_nm_RG.rds&quot;) 6.3.2.3 モデルチェック まず、DHARMaパッケージ(Hartig, 2022)とDHARMa.helperパッケージ(Rodríguez-Sánchez, 2023)でモデルの前提が満たされているかを確認します。 ## 全期間 dh_prox_nm_RG &lt;- dh_check_brms(m_prox_nm_RG, quantreg = TRUE) 多重共線性の問題もありません。 ## 全期間 check_collinearity(m_prox_nm_RG) bayesplotパッケージ(Gabry &amp; Mahr, 2022)のpp_check関数で、事後分布からの予測分布と実測値の分布を比較しても大きな乖離はない。 ## 全期間 pp_check(m_prox_nm_RG, ndraws = 100)+ theme_bw()+ theme(aspect.ratio = 0.9) Rhatにも問題はなく、収束の問題はないよう。 data.frame(Rhat = brms::rhat(m_prox_nm_RG)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) 6.3.2.4 結果の確認 まずは、全期間のデータを用いたモデルについてみる。太字になっている変数は95%確信区間が0をまたいでおらず、有意な影響があるといえる。 6.3.2.5 結果の図示 最後に、結果の図示をします。 まず、TYの有無についてです。 emm_prox_nm_RG_TY &lt;- emmeans(m_prox_nm_RG, ~TY_presence) prox_data_nm_RG %&gt;% ggplot(aes(x = TY_presence, y = log(mean_prox))) + geom_violin(bw = 0.2, scale = &quot;width&quot;) + geom_boxplot(size = 0.5, linewidth = 0.4, width = 0.2, fill = &quot;grey&quot;, outlier.alpha = 0) + geom_point(data = emm_prox_nm_RG_TY %&gt;% data.frame() %&gt;% mutate(TY_presence = as.factor(TY_presence)), aes(y = emmean), size = 3, color = &quot;white&quot;) + geom_errorbar(data = emm_prox_nm_RG_TY %&gt;% data.frame() %&gt;% mutate(TY_presence = as.factor(TY_presence)), aes(y = emmean, ymin = lower.HPD, ymax = upper.HPD), size = 0.4, color = &quot;white&quot;, width = 0.1) + theme_bw(base_size = 12) + scale_x_discrete(labels = c(&quot;*TY* absent&quot;, &quot;*TY* present&quot;)) + labs(x = &quot;&quot;, y = &quot;log(mean resting group size)&quot;) + theme(text = element_text(family = &quot;Times New Roman&quot;), axis.text.x = element_markdown(), aspect.ratio = 1) -&gt; p_prox_nm_RG_TY p_prox_nm_RG_TY ggsave(&quot;figures/p_prox_nm_RG_TY.tif&quot;, p_prox_nm_RG_TY, dpi = 2000, units = &quot;mm&quot;, width = 100, height = 100) 6.4 近接個体数の分析(採食中) 最後に、TYやITの有無を含む様々な要因が個体追跡中の周辺メス数に影響するかを検討します。 6.4.1 交尾期(非発情メス) 6.4.1.1 データの加工 まず、非発情メスについて分析を行うためのデータを作成します。連続変数は標準化します。 休息ポイント数が10以上の個体追跡セッションのみを使用 ハドリングのポイントは除去 地上休息のみを含む prox_data_an_F &lt;- focal_combined_prox_final %&gt;% mutate(rate_female = no_female/max_female) %&gt;% filter(rs2 == 0) %&gt;% replace_na(list(hud = 0)) %&gt;% filter(hud != &quot;1&quot;) %&gt;% filter(activity == &quot;F&quot; &amp; T_G == &quot;G&quot;) %&gt;% group_by(date, no_focal, subject, study_period, rate_agg_6yo, no_ntm, no_est, no_male, no_female, TY_presence, no_kin, IT_presence, CSI_TY) %&gt;% summarise(sum_prox = sum(x3m_female + 1), n = n()) %&gt;% ungroup() %&gt;% mutate(TY_presence = as.factor(TY_presence), IT_presence = as.factor(IT_presence)) %&gt;% filter(study_period != &quot;m18&quot;) %&gt;% filter(n &gt;= 10) %&gt;% mutate(ntm_std = standardize(no_ntm), male_std = standardize(no_male), est_std = standardize(no_est), kin_std = standardize(no_kin), female_std = standardize(no_female), rate_agg_std = standardize(rate_agg_6yo), CSI_TY_std = standardize(CSI_TY), mean_prox = sum_prox/n) prox_data_an_F 共変量と応答変数(平均休息集団サイズ)の関連を図示すると以下のようになります。 prox_data_an_F %&gt;% pivot_longer(cols = c(no_ntm, no_est, no_female, rate_agg_6yo, kin_std, CSI_TY), names_to = &quot;type&quot;, values_to = &quot;value&quot;) %&gt;% ggplot(aes(x = value, y = mean_prox)) + geom_point(shape = 1) + facet_rep_wrap(~ type, scales = &quot;free&quot;) + theme_bw(base_size = 12) + theme(aspect.ratio = 1) + labs(x = &quot;&quot;, y = &quot;Mean resting group size&quot;) 6.4.1.2 モデリング それでは、モデリングを行います。以下のように行いました。連続変数は標準化しています。また、ITの効果を見る際には、2021年交尾期を除くモデルを作成しました。 応答変数: log(平均休息集団サイズ(メスのみ)) 分布: Studentのt分布 説明変数: TYの在不在(TY_presence)、ITの在不在(IT_presence)、群れ外オス数(ntm_std)、集団内の発情メス数(est_std)、集団内のメス数(female_std)、集団内の血縁メス数(kin_est)、調査期間(study_period) ランダム切片: subject ## 2019~2021年 m_prox_an_F &lt;- brm(log(mean_prox) ~ TY_presence + IT_presence + ntm_std + est_std + female_std + kin_std + study_period + (1|subject) + (1|date), family = student, iter = 11000, warmup = 1000, seed = 123, prior = c(prior(student_t(4,0,5), class = &quot;b&quot;), prior(student_t(4,0,10), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;), prior(student_t(4,0,10), class = &quot;nu&quot;), prior(student_t(4,0,10), class = &quot;sigma&quot;)), control = list(adapt_delta = 0.99, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = prox_data_an_F, file = &quot;model/m_prox_an_F.rds&quot;) ## 2019~2020年 prox_data_an_F_bf21 &lt;- prox_data_an_F %&gt;% filter(study_period != &quot;m21&quot;) %&gt;% mutate(ntm_std = standardize(no_ntm), male_std = standardize(no_male), est_std = standardize(no_est), kin_std = standardize(no_kin), female_std = standardize(no_female), rate_agg_std = standardize(rate_agg_6yo), CSI_TY_std = standardize(CSI_TY), mean_prox = sum_prox/n) m_prox_an_F_bf21 &lt;- brm(log(mean_prox) ~ TY_presence + IT_presence + ntm_std + est_std + female_std + kin_std + study_period + (1|subject), family = student, iter = 11000, warmup = 1000, seed = 123, prior = c(prior(student_t(4,0,5), class = &quot;b&quot;), prior(student_t(4,0,10), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;)), control = list(adapt_delta = 0.99, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = prox_data_an_F_bf21, file = &quot;model/m_prox_an_F_bf21.rds&quot;) 6.4.1.3 モデルチェック まず、DHARMaパッケージ(Hartig, 2022)とDHARMa.helperパッケージ(Rodríguez-Sánchez, 2023)でモデルの前提が満たされているかを確認します。 ## 全期間 dh_prox_an_F &lt;- dh_check_brms(m_prox_an_F, quantreg = TRUE) ## 21年より前 dh_prox_an_F_bf21 &lt;- dh_check_brms(m_prox_an_F_bf21, quantreg = TRUE) 多重共線性の問題もありません。 ## 全期間 check_collinearity(m_prox_an_F) ## 21年より前 check_collinearity(m_prox_an_F_bf21) bayesplotパッケージ(Gabry &amp; Mahr, 2022)のpp_check関数で、事後分布からの予測分布と実測値の分布を比較しても大きな乖離はない。 ## 全期間 pp_check(m_prox_an_F, ndraws = 100)+ theme_bw()+ theme(aspect.ratio = 0.9) ## 21年より前 pp_check(m_prox_an_F_bf21, ndraws = 100)+ theme_bw()+ theme(aspect.ratio = 0.9) Rhatにも問題はなく、収束の問題はないよう。 data.frame(Rhat = brms::rhat(m_prox_an_F)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) data.frame(Rhat = brms::rhat(m_prox_an_F_bf21)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) 6.4.1.4 結果の確認 まずは、全期間のデータを用いたモデルについてみる。太字になっている変数は95%確信区間が0をまたいでおらず、有意な影響があるといえる。 続いて、2021年のデータを除いたモデルについて確認する。 6.4.1.5 結果の図示 最後に、結果の図示をします。 まず、TYの有無についてです。 emm_prox_an_F_TY &lt;- emmeans(m_prox_an_F, ~TY_presence) prox_data_an_F %&gt;% ggplot(aes(x = TY_presence, y = log(mean_prox))) + geom_violin(bw = 0.1, scale = &quot;width&quot;) + geom_boxplot(size = 0.5, linewidth = 0.4, width = 0.2, fill = &quot;grey&quot;, outlier.alpha = 0) + geom_point(data = emm_prox_an_F_TY %&gt;% data.frame() %&gt;% mutate(TY_presence = as.factor(TY_presence)), aes(y = emmean), size = 3, color = &quot;white&quot;) + geom_errorbar(data = emm_prox_an_F_TY %&gt;% data.frame() %&gt;% mutate(TY_presence = as.factor(TY_presence)), aes(y = emmean, ymin = lower.HPD, ymax = upper.HPD), size = 0.4, color = &quot;white&quot;, width = 0.1) + geom_signif(comparisons = list(c(&quot;0&quot;, &quot;1&quot;)), y_position = 1.3, annotations = &quot;***&quot;) + theme_bw(base_size = 12) + scale_x_discrete(labels = c(&quot;*TY* absent&quot;, &quot;*TY* present&quot;)) + labs(x = &quot;&quot;, y = &quot;log(mean no. of females within 3m)&quot;) + theme(text = element_text(family = &quot;Times New Roman&quot;), axis.text.x = element_markdown(), aspect.ratio = 1) -&gt; p_prox_an_F_TY p_prox_an_F_TY ggsave(&quot;figures/p_prox_an_F_TY.tif&quot;, p_prox_an_F_TY, dpi = 2000, units = &quot;mm&quot;, width = 100, height = 100) 続いて、ITについてです。 emm_prox_an_F_IT &lt;- emmeans(m_prox_an_F_bf21, ~IT_presence) prox_data_an_F_bf21 %&gt;% ggplot(aes(x = IT_presence, y = log(mean_prox))) + geom_violin(bw = 0.07, scale = &quot;width&quot;) + geom_boxplot(size = 0.5, linewidth = 0.4, width = 0.2, fill = &quot;grey&quot;, outlier.alpha = 0) + geom_point(data = emm_prox_an_F_IT %&gt;% data.frame() %&gt;% mutate(IT_presence = as.factor(IT_presence)), aes(y = emmean), size = 3, color = &quot;white&quot;) + geom_errorbar(data = emm_prox_an_F_IT %&gt;% data.frame() %&gt;% mutate(IT_presence = as.factor(IT_presence)), aes(y = emmean, ymin = lower.HPD, ymax = upper.HPD), size = 0.4, color = &quot;white&quot;, width = 0.1) + theme_bw(base_size = 12) + scale_x_discrete(labels = c(&quot;*IT* absent&quot;, &quot;*IT* present&quot;)) + labs(x = &quot;&quot;, y = &quot;log(mean resting group size)&quot;) + theme(text = element_text(family = &quot;Times New Roman&quot;), axis.text.x = element_markdown(), aspect.ratio = 1) -&gt; p_prox_an_F_IT p_prox_an_F_IT ggsave(&quot;figures/p_prox_an_F_IT.tif&quot;, p_prox_an_F_IT, dpi = 2000, units = &quot;mm&quot;, width = 100, height = 100) 6.4.2 非交尾期 6.4.2.1 データの加工 続いて、非交尾期について分析を行うためのデータを作成します。連続変数は標準化します。 休息ポイント数が10以上の個体追跡セッションのみを使用 ハドリングのポイントは除去 地上休息のみを含む prox_data_nm_F &lt;- focal_combined_prox_final %&gt;% mutate(rate_female = no_female/max_female) %&gt;% filter(str_detect(study_period, &quot;nm&quot;)) %&gt;% replace_na(list(hud = 0)) %&gt;% filter(hud != &quot;1&quot;) %&gt;% filter(activity == &quot;F&quot; &amp; T_G == &quot;G&quot;) %&gt;% group_by(date, no_focal, subject, study_period, no_female, TY_presence, no_kin, IT_presence) %&gt;% summarise(sum_prox = sum(x3m_female + 1), n = n()) %&gt;% ungroup() %&gt;% mutate(TY_presence = as.factor(TY_presence), IT_presence = as.factor(IT_presence)) %&gt;% filter(study_period != &quot;m18&quot;) %&gt;% filter(n &gt;= 10) %&gt;% mutate(kin_std = standardize(no_kin), female_std = standardize(no_female), mean_prox = sum_prox/n) prox_data_nm_F 共変量と応答変数(平均休息集団サイズ)の関連を図示すると以下のようになります。 prox_data_nm_F %&gt;% pivot_longer(cols = c(no_female, no_kin), names_to = &quot;type&quot;, values_to = &quot;value&quot;) %&gt;% ggplot(aes(x = value, y = mean_prox)) + geom_point(shape = 1) + facet_rep_wrap(~ type, scales = &quot;free&quot;) + theme_bw(base_size = 12) + theme(aspect.ratio = 1) + labs(x = &quot;&quot;, y = &quot;Mean resting group size&quot;) 6.4.2.2 モデリング それでは、モデリングを行います。以下のように行いました。連続変数は標準化しています。また、ITの効果を見る際には、2021年交尾期を除くモデルを作成しました。 応答変数: log(平均休息集団サイズ(メスのみ)) 分布: Studentのt分布 説明変数: TYの在不在(TY_presence)、ITの在不在(IT_presence)、群れ外オス数(ntm_std)、集団内の発情メス数(est_std)、集団内のメス数(female_std)、集団内の血縁メス数(kin_est)、調査期間(study_period) ランダム切片: subject ## 2019~2021年 m_prox_nm_F &lt;- brm(log(mean_prox) ~ TY_presence + kin_std + study_period + (1|subject), family = student, iter = 11000, warmup = 1000, seed = 195, prior = c(prior(student_t(4,0,5), class = &quot;b&quot;), prior(student_t(4,0,10), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;), prior(student_t(4,0,10), class = &quot;nu&quot;), prior(student_t(4,0,10), class = &quot;sigma&quot;)), control = list(adapt_delta = 0.99, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = prox_data_nm_F, file = &quot;model/m_prox_nm_F.rds&quot;) 6.4.2.3 モデルチェック まず、DHARMaパッケージ(Hartig, 2022)とDHARMa.helperパッケージ(Rodríguez-Sánchez, 2023)でモデルの前提が満たされているかを確認します。 ## 全期間 dh_prox_nm_F &lt;- dh_check_brms(m_prox_nm_F, quantreg = TRUE) 多重共線性の問題もありません。 ## 全期間 check_collinearity(m_prox_nm_F) bayesplotパッケージ(Gabry &amp; Mahr, 2022)のpp_check関数で、事後分布からの予測分布と実測値の分布を比較しても大きな乖離はない。 ## 全期間 pp_check(m_prox_nm_F, ndraws = 100)+ theme_bw()+ theme(aspect.ratio = 0.9) Rhatにも問題はなく、収束の問題はないよう。 data.frame(Rhat = brms::rhat(m_prox_nm_F)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) 6.4.2.4 結果の確認 まずは、全期間のデータを用いたモデルについてみる。太字になっている変数は95%確信区間が0をまたいでおらず、有意な影響があるといえる。 6.4.2.5 結果の図示 最後に、結果の図示をします。 まず、TYの有無についてです。 emm_prox_nm_F_TY &lt;- emmeans(m_prox_nm_F, ~TY_presence) prox_data_nm_F %&gt;% ggplot(aes(x = TY_presence, y = log(mean_prox))) + geom_violin(bw = 0.2, scale = &quot;width&quot;) + geom_boxplot(size = 0.5, linewidth = 0.4, width = 0.2, fill = &quot;grey&quot;, outlier.alpha = 0) + geom_point(data = emm_prox_nm_F_TY %&gt;% data.frame() %&gt;% mutate(TY_presence = as.factor(TY_presence)), aes(y = emmean), size = 3, color = &quot;white&quot;) + geom_errorbar(data = emm_prox_nm_F_TY %&gt;% data.frame() %&gt;% mutate(TY_presence = as.factor(TY_presence)), aes(y = emmean, ymin = lower.HPD, ymax = upper.HPD), size = 0.4, color = &quot;white&quot;, width = 0.1) + theme_bw(base_size = 12) + scale_x_discrete(labels = c(&quot;*TY* absent&quot;, &quot;*TY* present&quot;)) + labs(x = &quot;&quot;, y = &quot;log(mean resting group size)&quot;) + theme(text = element_text(family = &quot;Times New Roman&quot;), axis.text.x = element_markdown(), aspect.ratio = 1) -&gt; p_prox_nm_F_TY p_prox_nm_F_TY ggsave(&quot;figures/p_prox_nm_F_TY.tif&quot;, p_prox_nm_F_TY, dpi = 2000, units = &quot;mm&quot;, width = 100, height = 100) References Gabry, J., &amp; Mahr, T. (2022). Bayesplot: Plotting for bayesian models. https://mc-stan.org/bayesplot Hartig, F. (2022). DHARMa: Residual diagnostics for hierarchical (multi-level / mixed) regression models. https://CRAN.R-project.org/package=DHARMa Rodríguez-Sánchez, F. (2023). DHARMa.helpers: Helper functions to check models not (yet) directly supported by DHARMa. "],["08_cohesion_aggression.html", "7 TYとの近接と被攻撃との関連 7.1 TY/ITとの近接と被攻撃頻度の関連 7.2 休息集団内のオスの有無と被攻撃頻度", " 7 TYとの近接と被攻撃との関連 ここでは、交尾期においてTYやITとの近接がオスからの被攻撃頻度に及ぼす影響を調べていきます。 7.1 TY/ITとの近接と被攻撃頻度の関連 まずは、休息集団内にTYとITがいるか否かによって、メスの被攻撃頻度が変わるかを検討します。 7.1.1 非発情メス 非発情メスについての分析を行います。 7.1.1.1 データの加工 分析のためのデータを作成します。データの独立性を担保するため、3分ごとのデータを用います。そのほかは以下の通りです。 地上にいるデータのみを用いる 連続変数は標準化 ## 地上のデータ、交尾期のデータを抽出 focal_agg_prox_an &lt;- focal_combined_prox_final %&gt;% filter(rs2 == 0) %&gt;% filter(T_G == &quot;G&quot;) %&gt;% filter(time %% 3 == 0) %&gt;% filter(!str_detect(study_period, &quot;nm&quot;)) %&gt;% mutate(focalID = str_c(study_period, &quot;_&quot;, no_focal)) %&gt;% mutate(CSI_TY_std = standardize(CSI_TY), CSI_IT_std = standardize(CSI_IT), ntm_std = standardize(no_ntm), est_std = standardize(no_est), female_std = standardize(no_female), x3m_female_std = standardize(x3m_female)) focal_agg_prox_an 7.1.1.2 モデリング それでは、モデリングを行います。調査期間は多重共線性が大きくなるため除外しました。 応答変数: 直後1分間の攻撃の有無(agg_focal) 説明変数: 3m以内のメス数(x3m_female)、3m以内のオスの有無(TY_3m, IT_3m, KR_3m)、調査日の確認メス数(female_std)、調査日の発情メス数(est_std)、追跡中のTYとITの有無(TY_presence、IT_presence) ランダム切片: メスID(subject)、追跡セッションID(focalID) 分布: ベルヌーイ分布 ## 全期間 m_agg_prox_an &lt;- brm(agg_focal ~ x3m_female_std + TY_3m + IT_3m + KR_3m + female_std + est_std + TY_presence + IT_presence + (1|focalID) + (1|subject), family = bernoulli, iter = 11000, warmup = 1000, seed = 13, prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), prior(student_t(4,0,15), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;)), control=list(adapt_delta = 0.9999, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = focal_agg_prox_an, file = &quot;model/m_agg_prox_an.rds&quot;) ## 2020年交尾期以前 focal_agg_prox_an_bf21 &lt;- focal_agg_prox_an %&gt;% filter(study_period != &quot;m21&quot;) %&gt;% mutate(CSI_TY_std = standardize(CSI_TY), CSI_IT_std = standardize(CSI_IT), ntm_std = standardize(no_ntm), est_std = standardize(no_est), female_std = standardize(no_female), x3m_female_std = standardize(x3m_female)) m_agg_prox_an_bf21 &lt;- brm(agg_focal ~ x3m_female_std + TY_3m + IT_3m + KR_3m + female_std + est_std + TY_presence + IT_presence + (1|focalID) + (1|subject), family = bernoulli, iter = 11000, warmup = 1000, seed = 13, prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), prior(student_t(4,0,15), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;)), control=list(adapt_delta = 0.9999, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = focal_agg_prox_an_bf21, file = &quot;model/m_agg_prox_an_bf21.rds&quot;) 7.1.1.3 モデルチェック まず、DHARMaパッケージ(Hartig, 2022)とDHARMa.helperパッケージ(Rodríguez-Sánchez, 2023)でモデルの前提が満たされているかを確認します。 ## 全期間 dh_agg_prox_an &lt;- dh_check_brms(m_agg_prox_an, quantreg = TRUE) ## 21年より前 dh_agg_prox_an_bf21 &lt;- dh_check_brms(m_agg_prox_an_bf21, quantreg = TRUE) 多重共線性の問題もありません。 ## 全期間 check_collinearity(m_agg_prox_an) ## 21年より前 check_collinearity(m_agg_prox_an_bf21) bayesplotパッケージ(Gabry &amp; Mahr, 2022)のpp_check関数で、事後分布からの予測分布と実測値の分布を比較しても大きな乖離はない。 ## 全期間 pp_check(m_agg_prox_an, ndraws = 100)+ theme_bw()+ theme(aspect.ratio = 0.9) ## 21年より前 pp_check(m_agg_prox_an_bf21, ndraws = 100)+ theme_bw()+ theme(aspect.ratio = 0.9) Rhatにも問題はなく、収束の問題はないよう。 data.frame(Rhat = brms::rhat(m_agg_prox_an)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) data.frame(Rhat = brms::rhat(m_agg_prox_an_bf21)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) 最後に、残差の時系列相関を調べます。まずは全期間についてです。有意な時系列相関はないようです。 ## 全時間ポイントの作成 focal_agg_prox_an_full &lt;- focal_agg_prox_an %&gt;% drop_na(agg_focal) %&gt;% mutate(resid = dh_agg_prox_an$scaledResiduals) ## 日ごとに個体追跡セッション番号を作成 date_focal_list &lt;- focal_agg_prox_an_full %&gt;% distinct(date, focalID) %&gt;% group_by(date) %&gt;% mutate(dateID = 1:n()) %&gt;% ungroup() ## フォーカル間に入れる空白行 time_blank_agg_prox_an &lt;- focal_agg_prox_an_full %&gt;% group_by(focalID, date, subject) %&gt;% summarise(time = max(time) + 1) %&gt;% group_by(focalID, date, subject) %&gt;% complete(time = seq(time, time + 30, by = 3)) %&gt;% ungroup() %&gt;% mutate(resid = NA) focal_agg_prox_an_full2 &lt;- focal_agg_prox_an_full %&gt;% left_join(date_focal_list) %&gt;% ## 時刻を作成 ## 2018年はかぶらないように作成 group_by(focalID) %&gt;% mutate(start_time = case_when( study_period == &quot;m18&quot; ~ make_datetime(year(date), month(date), mday(date), hour = unique(dateID*3), min = 0, sec = 0), .default = start_time )) %&gt;% ungroup() %&gt;% mutate(actualtime = start_time + time) %&gt;% group_by(focalID) %&gt;% complete(time = full_seq(time, 1)) %&gt;% filter(time %% 3 == 0) %&gt;% full_join(time_blank_agg_prox_an) %&gt;% arrange(focalID, time) ## 自己相関の図示 acf(focal_agg_prox_an_full2$resid, lag.max = 10, na.action = na.pass) ## Box-Ljung test Box.test(focal_agg_prox_an_full2$resid, type = &quot;Ljung-Box&quot;, lag = 10) ## ## Box-Ljung test ## ## data: focal_agg_prox_an_full2$resid ## X-squared = 8.3965, df = 10, p-value = 0.5902 2021年交尾期を除いた場合も同じです。 ## 全時間ポイントの作成 focal_agg_prox_an_bf21_full &lt;- focal_agg_prox_an_bf21 %&gt;% drop_na(agg_focal) %&gt;% mutate(resid = dh_agg_prox_an_bf21$scaledResiduals) ## 日ごとに個体追跡セッション番号を作成 date_focal_list &lt;- focal_agg_prox_an_bf21_full %&gt;% distinct(date, focalID) %&gt;% group_by(date) %&gt;% mutate(dateID = 1:n()) %&gt;% ungroup() ## フォーカル間に入れる空白行 time_blank_agg_prox_an_bf21 &lt;- focal_agg_prox_an_bf21_full %&gt;% group_by(focalID, date, subject) %&gt;% summarise(time = max(time) + 1) %&gt;% group_by(focalID, date, subject) %&gt;% complete(time = seq(time, time + 30, by = 3)) %&gt;% ungroup() %&gt;% mutate(resid = NA) focal_agg_prox_an_bf21_full2 &lt;- focal_agg_prox_an_bf21_full %&gt;% left_join(date_focal_list) %&gt;% ## 時刻を作成 ## 2018年はかぶらないように作成 group_by(focalID) %&gt;% mutate(start_time = case_when( study_period == &quot;m18&quot; ~ make_datetime(year(date), month(date), mday(date), hour = unique(dateID*3), min = 0, sec = 0), .default = start_time )) %&gt;% ungroup() %&gt;% mutate(actualtime = start_time + time) %&gt;% group_by(focalID) %&gt;% complete(time = full_seq(time, 1)) %&gt;% filter(time %% 3 == 0) %&gt;% full_join(time_blank_agg_prox_an_bf21) %&gt;% arrange(focalID, time) ## 自己相関の図示 acf(focal_agg_prox_an_bf21_full2$resid, lag.max = 10, na.action = na.pass) ## Box-Ljung test Box.test(focal_agg_prox_an_bf21_full2$resid, type = &quot;Ljung-Box&quot;, lag = 10) ## ## Box-Ljung test ## ## data: focal_agg_prox_an_bf21_full2$resid ## X-squared = 12.85, df = 10, p-value = 0.2322 7.1.1.4 結果の確認 まずは、全期間のデータを用いたモデルについてみる。太字になっている変数は95%確信区間が0をまたいでおらず、有意な影響があるといえる。 続いて、2021年のデータを除いたモデルについて確認する。 7.1.2 発情メス 発情メスについての分析を行います。 7.1.2.1 データの加工 分析のためのデータを作成します。データの独立性を担保するため、3分ごとのデータを用います。そのほかは以下の通りです。 地上にいるデータのみを用いる 連続変数は標準化 ## 地上のデータ、交尾期のデータを抽出 focal_agg_prox_es &lt;- focal_combined_prox_final %&gt;% filter(rs2 == 1) %&gt;% filter(T_G == &quot;G&quot;) %&gt;% filter(time %% 3 == 0) %&gt;% filter(!str_detect(study_period, &quot;nm&quot;)) %&gt;% mutate(focalID = str_c(study_period, &quot;_&quot;, no_focal)) %&gt;% mutate(CSI_TY_std = standardize(CSI_TY), CSI_IT_std = standardize(CSI_IT), ntm_std = standardize(no_ntm), est_std = standardize(no_est), female_std = standardize(no_female), x3m_female_std = standardize(x3m_female)) focal_agg_prox_es 7.1.2.2 モデリング それでは、モデリングを行います。調査期間は多重共線性が大きくなるため除外しました。 応答変数: 直後1分間の攻撃の有無(agg_focal) 説明変数: 3m以内のメス数(x3m_female)、3m以内のオスの有無(TY_3m, IT_3m, KR_3m)、調査日の確認メス数(female_std)、調査日の発情メス数(est_std)、追跡中のTYとITの有無(TY_presence、IT_presence) ランダム切片: メスID(subject)、追跡セッションID(focalID) 分布: ベルヌーイ分布(21年を除いたものはベータ二項分布) ## 全期間 m_agg_prox_es &lt;- brm(agg_focal ~ x3m_female_std + TY_3m + IT_3m + KR_3m + female_std + est_std + TY_presence + IT_presence + (1|focalID) + (1|subject), family = bernoulli, iter = 11000, warmup = 1000, seed = 13, prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), prior(student_t(4,0,15), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;)), control=list(adapt_delta = 0.9999, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = focal_agg_prox_es, file = &quot;model/m_agg_prox_es.rds&quot;) ## 2020年交尾期以前 focal_agg_prox_es_bf21 &lt;- focal_agg_prox_es %&gt;% filter(study_period != &quot;m21&quot;) %&gt;% mutate(CSI_TY_std = standardize(CSI_TY), CSI_IT_std = standardize(CSI_IT), ntm_std = standardize(no_ntm), est_std = standardize(no_est), female_std = standardize(no_female), x3m_female_std = standardize(x3m_female)) %&gt;% mutate(rowid = 1:n()) ## divergent transitionが少し出る m_agg_prox_es_bf21 &lt;- brm(agg_focal|trials(1) ~ x3m_female_std + TY_3m + IT_3m + KR_3m + female_std + est_std + TY_presence + IT_presence + (1|focalID) + (1|subject), family = beta_binomial(), iter = 11000, warmup = 1000, seed = 1106, prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), prior(student_t(4,0,15), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;)), control=list(adapt_delta = 0.99999, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = focal_agg_prox_es_bf21, file = &quot;model/m_agg_prox_es_bf21.rds&quot;) 7.1.2.3 モデルチェック まず、DHARMaパッケージ(Hartig, 2022)とDHARMa.helperパッケージ(Rodríguez-Sánchez, 2023)でモデルの前提が満たされているかを確認します。21年を除いた場合に少し悪そう。 ## 全期間 dh_agg_prox_es &lt;- dh_check_brms(m_agg_prox_es, quantreg = TRUE) ## 21年より前 dh_agg_prox_es_bf21 &lt;- dh_check_brms(m_agg_prox_es_bf21, quantreg = TRUE) 多重共線性の問題もありません。 ## 全期間 check_collinearity(m_agg_prox_es) ## 21年より前 check_collinearity(m_agg_prox_es_bf21) bayesplotパッケージ(Gabry &amp; Mahr, 2022)のpp_check関数で、事後分布からの予測分布と実測値の分布を比較しても大きな乖離はない。 ## 全期間 pp_check(m_agg_prox_es, ndraws = 100)+ theme_bw()+ theme(aspect.ratio = 0.9) ## 21年より前 pp_check(m_agg_prox_es_bf21, ndraws = 100)+ theme_bw()+ theme(aspect.ratio = 0.9) Rhatにも問題はなく、収束の問題はないよう。 data.frame(Rhat = brms::rhat(m_agg_prox_es)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) data.frame(Rhat = brms::rhat(m_agg_prox_es_bf21)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) 最後に、残差の時系列相関を調べます。まずは全期間についてです。有意な時系列相関はないようです。 ## 全時間ポイントの作成 focal_agg_prox_es_full &lt;- focal_agg_prox_es %&gt;% drop_na(agg_focal) %&gt;% mutate(resid = dh_agg_prox_es$scaledResiduals) ## 日ごとに個体追跡セッション番号を作成 date_focal_list &lt;- focal_agg_prox_es_full %&gt;% distinct(date, focalID) %&gt;% group_by(date) %&gt;% mutate(dateID = 1:n()) %&gt;% ungroup() ## フォーカル間に入れる空白行 time_blank_agg_prox_es &lt;- focal_agg_prox_es_full %&gt;% group_by(focalID, date, subject) %&gt;% summarise(time = max(time) + 1) %&gt;% group_by(focalID, date, subject) %&gt;% complete(time = seq(time, time + 30, by = 3)) %&gt;% ungroup() %&gt;% mutate(resid = NA) focal_agg_prox_es_full2 &lt;- focal_agg_prox_es_full %&gt;% left_join(date_focal_list) %&gt;% ## 時刻を作成 ## 2018年はかぶらないように作成 group_by(focalID) %&gt;% mutate(start_time = case_when( study_period == &quot;m18&quot; ~ make_datetime(year(date), month(date), mday(date), hour = unique(dateID*3), min = 0, sec = 0), .default = start_time )) %&gt;% ungroup() %&gt;% mutate(actualtime = start_time + time) %&gt;% group_by(focalID) %&gt;% complete(time = full_seq(time, 1)) %&gt;% filter(time %% 3 == 0) %&gt;% full_join(time_blank_agg_prox_es) %&gt;% arrange(focalID, time) ## 自己相関の図示 acf(focal_agg_prox_es_full2$resid, lag.max = 10, na.action = na.pass) ## Box-Ljung test Box.test(focal_agg_prox_es_full2$resid, type = &quot;Ljung-Box&quot;, lag = 10) ## ## Box-Ljung test ## ## data: focal_agg_prox_es_full2$resid ## X-squared = 3.1539, df = 10, p-value = 0.9776 2021年交尾期を除いた場合も同じです。 ## 全時間ポイントの作成 focal_agg_prox_es_bf21_full &lt;- focal_agg_prox_es_bf21 %&gt;% drop_na(agg_focal) %&gt;% mutate(resid = dh_agg_prox_es_bf21$scaledResiduals) ## 日ごとに個体追跡セッション番号を作成 date_focal_list &lt;- focal_agg_prox_es_bf21_full %&gt;% distinct(date, focalID) %&gt;% group_by(date) %&gt;% mutate(dateID = 1:n()) %&gt;% ungroup() ## フォーカル間に入れる空白行 time_blank_agg_prox_es_bf21 &lt;- focal_agg_prox_es_bf21_full %&gt;% group_by(focalID, date, subject) %&gt;% summarise(time = max(time) + 1) %&gt;% group_by(focalID, date, subject) %&gt;% complete(time = seq(time, time + 30, by = 3)) %&gt;% ungroup() %&gt;% mutate(resid = NA) focal_agg_prox_es_bf21_full2 &lt;- focal_agg_prox_es_bf21_full %&gt;% left_join(date_focal_list) %&gt;% ## 時刻を作成 ## 2018年はかぶらないように作成 group_by(focalID) %&gt;% mutate(start_time = case_when( study_period == &quot;m18&quot; ~ make_datetime(year(date), month(date), mday(date), hour = unique(dateID*3), min = 0, sec = 0), .default = start_time )) %&gt;% ungroup() %&gt;% mutate(actualtime = start_time + time) %&gt;% group_by(focalID) %&gt;% complete(time = full_seq(time, 1)) %&gt;% filter(time %% 3 == 0) %&gt;% full_join(time_blank_agg_prox_es_bf21) %&gt;% arrange(focalID, time) ## 自己相関の図示 acf(focal_agg_prox_es_bf21_full2$resid, lag.max = 10, na.action = na.pass) ## Box-Ljung test Box.test(focal_agg_prox_es_bf21_full2$resid, type = &quot;Ljung-Box&quot;, lag = 10) ## ## Box-Ljung test ## ## data: focal_agg_prox_es_bf21_full2$resid ## X-squared = 14.496, df = 10, p-value = 0.1515 7.1.2.4 結果の確認 まずは、全期間のデータを用いたモデルについてみる。太字になっている変数は95%確信区間が0をまたいでおらず、有意な影響があるといえる。 #### 結果の確認 まずは、全期間のデータを用いたモデルについてみる。太字になっている変数は95%確信区間が0をまたいでおらず、有意な影響があるといえる。 続いて、2021年のデータを除いたモデルについて確認する。 7.2 休息集団内のオスの有無と被攻撃頻度 7.2.1 非発情メス 非発情メスについての分析を行います。 7.2.1.1 データの加工 分析のためのデータを作成します。データの独立性を担保するため、3分ごとのデータを用います。そのほかは以下の通りです。 地上にいるデータのみを用いる 連続変数は標準化 ## 地上のデータ、交尾期のデータを抽出 focal_agg_RG_an &lt;- focal_combined_prox_final %&gt;% filter(rs2 == 0) %&gt;% filter(RG == 1 &amp; T_G == &quot;G&quot;) %&gt;% filter(time %% 3 == 0) %&gt;% filter(!str_detect(study_period, &quot;nm&quot;)) %&gt;% mutate(focalID = str_c(study_period, &quot;_&quot;, no_focal)) %&gt;% mutate(CSI_TY_std = standardize(CSI_TY), CSI_IT_std = standardize(CSI_IT), ntm_std = standardize(no_ntm), est_std = standardize(no_est), female_std = standardize(no_female), RG_female_std = standardize(RG_female)) 7.2.1.2 モデリング それでは、モデリングを行います。調査期間は多重共線性が大きくなるため除外しました。 応答変数: 直後1分間の攻撃の有無(agg_focal) 説明変数: 3m以内のメス数(x3m_female)、3m以内のオスの有無(TY_3m, IT_3m, KR_3m)、調査日の確認メス数(female_std)、調査日の発情メス数(est_std)、追跡中のTYとITの有無(TY_presence、IT_presence) ランダム切片: メスID(subject)、追跡セッションID(focalID) 分布: ベルヌーイ分布 ## 全期間 m_agg_RG_an &lt;- brm(agg_focal ~ RG_female_std + RG_TY + RG_IT + RG_KR + female_std + est_std + TY_presence + IT_presence + (1|focalID) + (1|subject), family = bernoulli, iter = 11000, warmup = 1000, seed = 123, prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), prior(student_t(4,0,15), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;)), control=list(adapt_delta = 0.9999, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = focal_agg_RG_an, file = &quot;model/m_agg_RG_an.rds&quot;) ## 2020年交尾期以前 focal_agg_RG_an_bf21 &lt;- focal_agg_RG_an %&gt;% filter(study_period != &quot;m21&quot;) %&gt;% mutate(CSI_TY_std = standardize(CSI_TY), CSI_IT_std = standardize(CSI_IT), ntm_std = standardize(no_ntm), est_std = standardize(no_est), female_std = standardize(no_female), RG_female_std = standardize(RG_female)) m_agg_RG_an_bf21 &lt;- brm(agg_focal ~ RG_female_std + RG_TY + RG_IT + RG_KR + female_std + est_std + TY_presence + IT_presence + (1|focalID) + (1|subject), family = bernoulli, iter = 11000, warmup = 1000, seed = 13, prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), prior(student_t(4,0,15), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;)), control=list(adapt_delta = 0.9999, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = focal_agg_RG_an_bf21, file = &quot;model/m_agg_RG_an_bf21.rds&quot;) 7.2.1.3 モデルチェック まず、DHARMaパッケージ(Hartig, 2022)とDHARMa.helperパッケージ(Rodríguez-Sánchez, 2023)でモデルの前提が満たされているかを確認します。 ## 全期間 dh_agg_RG_an &lt;- dh_check_brms(m_agg_RG_an, quantreg = TRUE) ## 21年より前 dh_agg_RG_an_bf21 &lt;- dh_check_brms(m_agg_RG_an_bf21, quantreg = TRUE) 多重共線性の問題もありません。 ## 全期間 check_collinearity(m_agg_RG_an) ## 21年より前 check_collinearity(m_agg_RG_an_bf21) bayesplotパッケージ(Gabry &amp; Mahr, 2022)のpp_check関数で、事後分布からの予測分布と実測値の分布を比較しても大きな乖離はない。 ## 全期間 pp_check(m_agg_RG_an, ndraws = 100)+ theme_bw() + theme(aspect.ratio = 0.9) ## 21年より前 pp_check(m_agg_RG_an_bf21, ndraws = 100)+ theme_bw() + theme(aspect.ratio = 0.9) Rhatにも問題はなく、収束の問題はないよう。 data.frame(Rhat = brms::rhat(m_agg_RG_an)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) data.frame(Rhat = brms::rhat(m_agg_RG_an_bf21)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) 最後に、残差の時系列相関を調べます。まずは全期間についてです。有意な時系列相関はないようです。 ## 全時間ポイントの作成 focal_agg_RG_an_full &lt;- focal_agg_RG_an %&gt;% drop_na(agg_focal) %&gt;% mutate(resid = dh_agg_RG_an$scaledResiduals) ## 日ごとに個体追跡セッション番号を作成 date_focal_list &lt;- focal_agg_RG_an_full %&gt;% distinct(date, focalID) %&gt;% group_by(date) %&gt;% mutate(dateID = 1:n()) %&gt;% ungroup() ## フォーカル間に入れる空白行 time_blank_agg_RG_an &lt;- focal_agg_RG_an_full %&gt;% group_by(focalID, date, subject) %&gt;% summarise(time = max(time) + 1) %&gt;% group_by(focalID, date, subject) %&gt;% complete(time = seq(time, time + 30, by = 3)) %&gt;% ungroup() %&gt;% mutate(resid = NA) focal_agg_RG_an_full2 &lt;- focal_agg_RG_an_full %&gt;% left_join(date_focal_list) %&gt;% ## 時刻を作成 ## 2018年はかぶらないように作成 group_by(focalID) %&gt;% mutate(start_time = case_when( study_period == &quot;m18&quot; ~ make_datetime(year(date), month(date), mday(date), hour = unique(dateID*3), min = 0, sec = 0), .default = start_time )) %&gt;% ungroup() %&gt;% mutate(actualtime = start_time + time) %&gt;% group_by(focalID) %&gt;% complete(time = full_seq(time, 1)) %&gt;% filter(time %% 3 == 0) %&gt;% full_join(time_blank_agg_RG_an) %&gt;% arrange(focalID, time) ## 自己相関の図示 acf(focal_agg_RG_an_full2$resid, lag.max = 10, na.action = na.pass) ## Box-Ljung test Box.test(focal_agg_RG_an_full2$resid, type = &quot;Ljung-Box&quot;, lag = 10) ## ## Box-Ljung test ## ## data: focal_agg_RG_an_full2$resid ## X-squared = 15.81, df = 10, p-value = 0.1052 2021年交尾期を除いた場合はあるようです。 ## 全時間ポイントの作成 focal_agg_RG_an_bf21_full &lt;- focal_agg_RG_an_bf21 %&gt;% drop_na(agg_focal) %&gt;% mutate(resid = dh_agg_RG_an_bf21$scaledResiduals) ## 日ごとに個体追跡セッション番号を作成 date_focal_list &lt;- focal_agg_RG_an_bf21_full %&gt;% distinct(date, focalID) %&gt;% group_by(date) %&gt;% mutate(dateID = 1:n()) %&gt;% ungroup() ## フォーカル間に入れる空白行 time_blank_agg_RG_an_bf21 &lt;- focal_agg_RG_an_bf21_full %&gt;% group_by(focalID, date, subject) %&gt;% summarise(time = max(time) + 1) %&gt;% group_by(focalID, date, subject) %&gt;% complete(time = seq(time, time + 30, by = 3)) %&gt;% ungroup() %&gt;% mutate(resid = NA) focal_agg_RG_an_bf21_full2 &lt;- focal_agg_RG_an_bf21_full %&gt;% left_join(date_focal_list) %&gt;% ## 時刻を作成 ## 2018年はかぶらないように作成 group_by(focalID) %&gt;% mutate(start_time = case_when( study_period == &quot;m18&quot; ~ make_datetime(year(date), month(date), mday(date), hour = unique(dateID*3), min = 0, sec = 0), .default = start_time )) %&gt;% ungroup() %&gt;% mutate(actualtime = start_time + time) %&gt;% group_by(focalID) %&gt;% complete(time = full_seq(time, 1)) %&gt;% filter(time %% 3 == 0) %&gt;% full_join(time_blank_agg_RG_an_bf21) %&gt;% arrange(focalID, time) ## 自己相関の図示 acf(focal_agg_RG_an_bf21_full2$resid, lag.max = 10, na.action = na.pass) ## Box-Ljung test Box.test(focal_agg_RG_an_bf21_full2$resid, type = &quot;Ljung-Box&quot;, lag = 10) ## ## Box-Ljung test ## ## data: focal_agg_RG_an_bf21_full2$resid ## X-squared = 29.385, df = 10, p-value = 0.001079 7.2.1.4 結果の確認 まずは、全期間のデータを用いたモデルについてみる。太字になっている変数は95%確信区間が0をまたいでおらず、有意な影響があるといえる。 続いて、2021年のデータを除いたモデルについて確認する。 7.2.2 発情メス 発情メスについての分析を行います。 7.2.2.1 データの加工 分析のためのデータを作成します。データの独立性を担保するため、3分ごとのデータを用います。そのほかは以下の通りです。 地上にいるデータのみを用いる 連続変数は標準化 ## 地上のデータ、交尾期のデータを抽出 focal_agg_RG_es &lt;- focal_combined_prox_final %&gt;% filter(rs2 == 1) %&gt;% filter(RG == 1 &amp; T_G == &quot;G&quot;) %&gt;% filter(time %% 3 == 0) %&gt;% filter(!str_detect(study_period, &quot;nm&quot;)) %&gt;% mutate(focalID = str_c(study_period, &quot;_&quot;, no_focal)) %&gt;% mutate(CSI_TY_std = standardize(CSI_TY), CSI_IT_std = standardize(CSI_IT), ntm_std = standardize(no_ntm), est_std = standardize(no_est), female_std = standardize(no_female), RG_female_std = standardize(RG_female)) 7.2.2.2 モデリング それでは、モデリングを行います。調査期間は多重共線性が大きくなるため除外しました。 応答変数: 直後1分間の攻撃の有無(agg_focal) 説明変数: 3m以内のメス数(x3m_female)、3m以内のオスの有無(TY_3m, IT_3m, KR_3m)、調査日の確認メス数(female_std)、調査日の発情メス数(est_std)、追跡中のTYとITの有無(TY_presence、IT_presence) ランダム切片: メスID(subject)、追跡セッションID(focalID) 分布: ベルヌーイ分布(21年を除いたものはベータ二項分布) ## 全期間 m_agg_RG_es &lt;- brm(agg_focal ~ RG_female_std + RG_TY + RG_IT + RG_KR + female_std + est_std + TY_presence + IT_presence + (1|focalID) + (1|subject), family = bernoulli, iter = 11000, warmup = 1000, seed = 13, prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), prior(student_t(4,0,15), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;)), control=list(adapt_delta = 0.9999, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = focal_agg_RG_es, file = &quot;model/m_agg_RG_es.rds&quot;) ## 2020年交尾期以前 focal_agg_RG_es_bf21 &lt;- focal_agg_RG_es %&gt;% filter(study_period != &quot;m21&quot;) %&gt;% mutate(CSI_TY_std = standardize(CSI_TY), CSI_IT_std = standardize(CSI_IT), ntm_std = standardize(no_ntm), est_std = standardize(no_est), female_std = standardize(no_female), RG_female_std = standardize(RG_female)) %&gt;% mutate(rowid = 1:n()) m_agg_RG_es_bf21 &lt;- brm(agg_focal|trials(1) ~ RG_female_std + RG_TY + RG_IT + RG_KR + female_std + est_std + TY_presence + IT_presence + (1|focalID) + (1|subject), family = binomial(), iter = 11000, warmup = 1000, seed = 123, prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), prior(student_t(4,0,15), class = &quot;Intercept&quot;), prior(student_t(4,0,10), class = &quot;sd&quot;)), control=list(adapt_delta = 0.99999, max_treedepth = 20), backend = &quot;cmdstanr&quot;, data = focal_agg_RG_es_bf21, file = &quot;model/m_agg_RG_es_bf21.rds&quot;) 7.2.2.3 モデルチェック まず、DHARMaパッケージ(Hartig, 2022)とDHARMa.helperパッケージ(Rodríguez-Sánchez, 2023)でモデルの前提が満たされているかを確認します。 ## 全期間 dh_agg_RG_es &lt;- dh_check_brms(m_agg_RG_es, quantreg = TRUE) ## 21年より前 dh_agg_RG_es_bf21 &lt;- dh_check_brms(m_agg_RG_es_bf21, quantreg = TRUE) 多重共線性の問題もありません。 ## 全期間 check_collinearity(m_agg_RG_es) ## 21年より前 check_collinearity(m_agg_RG_es_bf21) bayesplotパッケージ(Gabry &amp; Mahr, 2022)のpp_check関数で、事後分布からの予測分布と実測値の分布を比較しても大きな乖離はない。 ## 全期間 pp_check(m_agg_RG_es, ndraws = 100)+ theme_bw()+ theme(aspect.ratio = 0.9) ## 21年より前 pp_check(m_agg_RG_es_bf21, ndraws = 100)+ theme_bw()+ theme(aspect.ratio = 0.9) Rhatにも問題はなく、収束の問題はないよう。 data.frame(Rhat = brms::rhat(m_agg_RG_es)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) data.frame(Rhat = brms::rhat(m_agg_RG_es_bf21)) %&gt;% ggplot(aes(x = Rhat))+ geom_histogram(fill = &quot;white&quot;, color = &quot;black&quot;)+ theme_bw()+ theme(aspect.ratio = 1) 最後に、残差の時系列相関を調べます。まずは全期間についてです。有意な時系列相関はないようです。 ## 全時間ポイントの作成 focal_agg_RG_es_full &lt;- focal_agg_RG_es%&gt;% drop_na(agg_focal) %&gt;% mutate(resid = dh_agg_RG_es$scaledResiduals) %&gt;% group_by(focalID, subject, date) %&gt;% complete(time = full_seq(time, 1)) %&gt;% ungroup() ## 日ごとに個体追跡セッション番号を作成 date_focal_list &lt;- focal_agg_RG_es_full %&gt;% distinct(date, focalID) %&gt;% group_by(date) %&gt;% mutate(dateID = 1:n()) %&gt;% ungroup() focal_agg_RG_es_full2 &lt;- focal_agg_RG_es_full %&gt;% left_join(date_focal_list) %&gt;% ## 時刻を作成 ## 2018年はかぶらないように作成 group_by(focalID) %&gt;% mutate(start_time = case_when( study_period == &quot;m18&quot; ~ make_datetime(year(date), month(date), mday(date), hour = unique(dateID*3), min = 0, sec = 0), .default = start_time )) %&gt;% ungroup() %&gt;% mutate(actualtime = start_time + time) %&gt;% group_by(focalID) %&gt;% complete(time = full_seq(time, 1)) %&gt;% filter(time %% 3 == 0) ## 自己相関の図示 acf(focal_agg_RG_es_full2$resid, lag.max = 10, na.action = na.pass) ## Box-Ljung test Box.test(focal_agg_RG_es_full2$resid, type = &quot;Ljung-Box&quot;, lag = 10) ## ## Box-Ljung test ## ## data: focal_agg_RG_es_full2$resid ## X-squared = 5.1134, df = 10, p-value = 0.8835 2021年交尾期を除いた場合はわずかにあるよう。 ## 全時間ポイントの作成 focal_agg_RG_es_bf21_full &lt;- focal_agg_RG_es_bf21 %&gt;% drop_na(agg_focal) %&gt;% mutate(resid = dh_agg_RG_es_bf21$scaledResiduals) %&gt;% group_by(focalID, subject, date) %&gt;% complete(time = full_seq(time, 1)) %&gt;% ungroup() ## 日ごとに個体追跡セッション番号を作成 date_focal_list &lt;- focal_agg_RG_es_bf21_full %&gt;% distinct(date, focalID) %&gt;% group_by(date) %&gt;% mutate(dateID = 1:n()) %&gt;% ungroup() focal_agg_RG_es_bf21_full2 &lt;- focal_agg_RG_es_bf21_full %&gt;% left_join(date_focal_list) %&gt;% ## 時刻を作成 ## 2018年はかぶらないように作成 group_by(focalID) %&gt;% mutate(start_time = case_when( study_period == &quot;m18&quot; ~ make_datetime(year(date), month(date), mday(date), hour = unique(dateID*3), min = 0, sec = 0), .default = start_time )) %&gt;% ungroup() %&gt;% mutate(actualtime = start_time + time) %&gt;% group_by(focalID) %&gt;% complete(time = full_seq(time, 1)) %&gt;% filter(time %% 3 == 0) ## 自己相関の図示 acf(focal_agg_RG_es_bf21_full2$resid, lag.max = 10, na.action = na.pass) ## Box-Ljung test Box.test(focal_agg_RG_es_bf21_full2$resid, type = &quot;Ljung-Box&quot;, lag = 10) ## ## Box-Ljung test ## ## data: focal_agg_RG_es_bf21_full2$resid ## X-squared = 18.409, df = 10, p-value = 0.04845 7.2.2.4 結果の確認 まずは、全期間のデータを用いたモデルについてみる。太字になっている変数は95%確信区間が0をまたいでおらず、有意な影響があるといえる。 続いて、2021年のデータを除いたモデルについて確認する。 References Gabry, J., &amp; Mahr, T. (2022). Bayesplot: Plotting for bayesian models. https://mc-stan.org/bayesplot Hartig, F. (2022). DHARMa: Residual diagnostics for hierarchical (multi-level / mixed) regression models. https://CRAN.R-project.org/package=DHARMa Rodríguez-Sánchez, F. (2023). DHARMa.helpers: Helper functions to check models not (yet) directly supported by DHARMa. "],["09_RG_network.html", "8 休息中のネットワーク 8.1 データの加工 8.2 隣接行列の作成 8.3 ネットワーク指標の算出 8.4 ネットワークの描画 8.5 ネットワーク指標についての作図 8.6 統計的分析", " 8 休息中のネットワーク 休息集団のネットワークを書くことで、TYが休息集団内でどのような位置を占めていたのかを明らかにします。 8.1 データの加工 まず、休息集団の隣接行列を作成するためのデータを作成します。 各個体が休息集団にいたかを表すgroup by individual 形式のデータを作成します。 地上休息中のみを抽出 非発情メスののみを作成 交尾期と非交尾期は区別 ITがいた時期に絞ったネットワークも作成します。 メスは2019年時点で6歳以上の個体のみを含みます。 オスはTY、IT、KRのみを含みます。 focal_RG &lt;- focal_prox %&gt;% left_join(female_all %&gt;% select(femaleID, date, rs2), by = c(&quot;subject&quot; = &quot;femaleID&quot;, &quot;date&quot;)) %&gt;% filter(RG == &quot;1&quot; &amp; T_G == &quot;G&quot;) %&gt;% mutate(focalID = str_c(study_period, &quot;_&quot;, no_focal)) %&gt;% filter((study_period == &quot;m18&quot; &amp; ID %in% c(adult18, &quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;))| (study_period == &quot;nm19&quot; &amp; ID %in% c(adult18, &quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;))| (study_period == &quot;m19&quot; &amp; ID %in% c(adult19, &quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;))| (study_period == &quot;m20&quot; &amp; ID %in% c(adult20, &quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;))| (study_period == &quot;nm21&quot; &amp; ID %in% c(adult20, &quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;))| (study_period == &quot;m21&quot; &amp; ID %in% c(adult21, &quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;))| (study_period == &quot;nm22&quot; &amp; ID %in% c(adult21, &quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;))) %&gt;% select(date, study_period, focalID, time, TY_presence, IT_presence, rs2, subject, ID) %&gt;% mutate(presence = 1) %&gt;% complete(nesting(date, study_period, focalID, time, TY_presence, IT_presence, rs2, subject), ID = ID) %&gt;% mutate(presence = if_else(subject == ID, 1, presence)) %&gt;% replace_na(list(presence = 0)) %&gt;% pivot_wider(names_from = ID, values_from = presence) focal_RG 8.2 隣接行列の作成 交尾期は年によって追跡個体が異なるため、追跡個体のみに絞って隣接行列を作成します。途中で死亡している個体は除外します。 2018年、2019年: Mik, Kil, Tam, Koh, Aka, Ntr, Ten, Tot, Hen, Hot, Mei, Ako, Kol, Mal, Kit, Kun 2020年、2021年: Kil, Kol, Ntr, Ten, Mal, Hot, Aka female_1st &lt;- c(&quot;Mik&quot;, &quot;Kil&quot;, &quot;Tam&quot;, &quot;Koh&quot;, &quot;Aka&quot;, &quot;Ntr&quot;, &quot;Ten&quot;, &quot;Tot&quot;, &quot;Hen&quot;, &quot;Hot&quot;, &quot;Mei&quot;, &quot;Ako&quot;, &quot;Kol&quot;, &quot;Mal&quot;, &quot;Kit&quot;, &quot;Kun&quot;) female_2nd &lt;- c(&quot;Kil&quot;, &quot;Ntr&quot;, &quot;Ten&quot;, &quot;Hot&quot;, &quot;Kol&quot;, &quot;Mal&quot;, &quot;Aka&quot;)   また、TYがいる日の絞ったもの、ITがいる日の絞ったものをそれぞれ作成します。後者については、ITがいる期間に限定して作成します。 8.2.1 交尾期(非発情・2018~2019) 8.2.1.1 TYがいる日 focal_RG_an1_TY &lt;- focal_RG %&gt;% filter(rs2 == 0) %&gt;% filter(study_period %in% c(&quot;m18&quot;, &quot;m19&quot;)) %&gt;% filter(TY_presence == 1) %&gt;% select(one_of(female_1st), TY, KR, LK) ## 作成 mat_RG_an1_TY &lt;- get_network(focal_RG_an1_TY, data_format = &quot;GBI&quot;, association_index = &quot;SRI&quot;) ## Generating 19 x 19 matrix 隣接行列は以下の通り。 mat_RG_an1_TY %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot; &quot;) 8.2.1.2 ITがいる日 focal_RG_an1_IT &lt;- focal_RG %&gt;% filter(rs2 == 0) %&gt;% filter(study_period %in% c(&quot;m18&quot;, &quot;m19&quot;)) %&gt;% filter(IT_presence == 1) %&gt;% select(one_of(female_1st), IT, KR, LK) ## 作成 mat_RG_an1_IT &lt;- get_network(focal_RG_an1_IT, data_format = &quot;GBI&quot;, association_index = &quot;SRI&quot;) ## Generating 19 x 19 matrix 隣接行列は以下の通り。 mat_RG_an1_IT %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot; &quot;) 8.2.2 交尾期(非発情・2020~2021) 8.2.2.1 TYがいる日 focal_RG_an2_TY &lt;- focal_RG %&gt;% filter(rs2 == 0) %&gt;% filter(study_period %in% c(&quot;m20&quot;, &quot;m21&quot;)) %&gt;% filter(TY_presence == 1) %&gt;% select(one_of(female_2nd), TY, KR) ## 作成 mat_RG_an2_TY &lt;- get_network(focal_RG_an2_TY, data_format = &quot;GBI&quot;, association_index = &quot;SRI&quot;) ## Generating 9 x 9 matrix 隣接行列は以下の通り。 mat_RG_an2_TY %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot; &quot;) 8.2.2.2 ITがいる日 focal_RG_an2_IT &lt;- focal_RG %&gt;% filter(rs2 == 0) %&gt;% filter(study_period %in% c(&quot;m20&quot;, &quot;m21&quot;)) %&gt;% filter(IT_presence == 1) %&gt;% select(one_of(female_2nd), IT, KR) ## 作成 mat_RG_an2_IT &lt;- get_network(focal_RG_an2_IT, data_format = &quot;GBI&quot;, association_index = &quot;SRI&quot;) ## Generating 9 x 9 matrix 隣接行列は以下の通り。 mat_RG_an1_IT %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot; &quot;) 8.2.3 非交尾期 8.2.3.1 TYがいる日 focal_RG_nm_TY &lt;- focal_RG %&gt;% filter(study_period %in% c(&quot;nm19&quot;, &quot;nm20&quot;, &quot;nm21&quot;, &quot;nm22&quot;)) %&gt;% filter(TY_presence == 1) %&gt;% select(one_of(female_1st), TY, KR, -Tam) ## 作成 mat_RG_nm_TY &lt;- get_network(focal_RG_nm_TY, data_format = &quot;GBI&quot;, association_index = &quot;SRI&quot;) ## Generating 17 x 17 matrix 隣接行列は以下の通り。 mat_RG_nm_TY %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot; &quot;) 8.2.3.2 ITがいる日 focal_RG_nm_IT &lt;- focal_RG %&gt;% filter(study_period %in% c(&quot;nm19&quot;, &quot;nm20&quot;, &quot;nm21&quot;)) %&gt;% filter(IT_presence == 1) %&gt;% select(one_of(female_1st), IT, KR, -Tam) ## 作成 mat_RG_nm_IT &lt;- get_network(focal_RG_nm_IT, data_format = &quot;GBI&quot;, association_index = &quot;SRI&quot;) ## Generating 17 x 17 matrix 隣接行列は以下の通り。 mat_RG_nm_IT %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot; &quot;) 8.3 ネットワーク指標の算出 8.3.1 交尾期(非発情・2018~2019) 8.3.1.1 TYがいる日 ID_an1_TY &lt;- data.frame(ID = colnames(mat_RG_an1_TY)) ## 作成 metrics_an1_TY_eigen &lt;- met.eigen(mat_RG_an1_TY, binary = FALSE, sym = TRUE, df = ID_an1_TY, dfid = 1) metrics_an1_TY_strength &lt;- met.strength(mat_RG_an1_TY, df = metrics_an1_TY_eigen, dfid = 1) metrics_an1_TY_between &lt;- met.betweenness(mat_RG_an1_TY, binary = FALSE, sym = TRUE, df = metrics_an1_TY_strength, dfid = 1) ## TYとの親密度などの情報を結合 metrics_an1_TY &lt;- metrics_an1_TY_between %&gt;% left_join(CSI_TY_combined %&gt;% select(subject, CSI_TY), by = c(&quot;ID&quot; = &quot;subject&quot;)) %&gt;% left_join(att %&gt;% filter(study_period == &quot;m18&quot;) %&gt;% select(femaleID, age, rank), by = c(&quot;ID&quot; = &quot;femaleID&quot;)) 算出した指標はは以下の通り。 metrics_an1_TY 8.3.1.2 ITがいる日 ID_an1_IT &lt;- data.frame(ID = colnames(mat_RG_an1_IT)) ## 作成 metrics_an1_IT_eigen &lt;- met.eigen(mat_RG_an1_IT, binary = FALSE, sym = TRUE, df = ID_an1_IT, dfid = 1) metrics_an1_IT_strength &lt;- met.strength(mat_RG_an1_IT, df = metrics_an1_IT_eigen, dfid = 1) metrics_an1_IT_between &lt;- met.betweenness(mat_RG_an1_IT, binary = FALSE, sym = TRUE, df = metrics_an1_IT_strength, dfid = 1) ## ITとの親密度などの情報を結合 metrics_an1_IT &lt;- metrics_an1_IT_between %&gt;% left_join(CSI_IT_combined %&gt;% select(subject, CSI_IT), by = c(&quot;ID&quot; = &quot;subject&quot;)) %&gt;% left_join(att %&gt;% filter(study_period == &quot;m18&quot;) %&gt;% select(femaleID, age, rank), by = c(&quot;ID&quot; = &quot;femaleID&quot;)) 算出した指標はは以下の通り。 metrics_an1_IT 8.3.2 交尾期(非発情・2020~2021) 8.3.2.1 TYがいる日 ID_an2_TY &lt;- data.frame(ID = colnames(mat_RG_an2_TY)) ## 作成 metrics_an2_TY_eigen &lt;- met.eigen(mat_RG_an2_TY, binary = FALSE, sym = TRUE, df = ID_an2_TY, dfid = 1) metrics_an2_TY_strength &lt;- met.strength(mat_RG_an2_TY, df = metrics_an2_TY_eigen, dfid = 1) metrics_an2_TY_between &lt;- met.betweenness(mat_RG_an2_TY, binary = FALSE, sym = TRUE, df = metrics_an2_TY_strength, dfid = 1) ## TYとの親密度などの情報を結合 metrics_an2_TY &lt;- metrics_an2_TY_between %&gt;% left_join(CSI_TY_combined %&gt;% select(subject, CSI_TY), by = c(&quot;ID&quot; = &quot;subject&quot;)) %&gt;% left_join(att %&gt;% filter(study_period == &quot;m18&quot;) %&gt;% select(femaleID, age, rank), by = c(&quot;ID&quot; = &quot;femaleID&quot;)) 算出した指標はは以下の通り。 metrics_an2_TY 8.3.2.2 ITがいる日 ID_an2_IT &lt;- data.frame(ID = colnames(mat_RG_an2_IT)) ## 作成 metrics_an2_IT_eigen &lt;- met.eigen(mat_RG_an2_IT, binary = FALSE, sym = TRUE, df = ID_an2_IT, dfid = 1) metrics_an2_IT_strength &lt;- met.strength(mat_RG_an2_IT, df = metrics_an2_IT_eigen, dfid = 1) metrics_an2_IT_between &lt;- met.betweenness(mat_RG_an2_IT, binary = FALSE, sym = TRUE, df = metrics_an2_IT_strength, dfid = 1) ## ITとの親密度などの情報を結合 metrics_an2_IT &lt;- metrics_an2_IT_between %&gt;% left_join(CSI_IT_combined %&gt;% select(subject, CSI_IT), by = c(&quot;ID&quot; = &quot;subject&quot;)) %&gt;% left_join(att %&gt;% filter(study_period == &quot;m18&quot;) %&gt;% select(femaleID, age, rank), by = c(&quot;ID&quot; = &quot;femaleID&quot;)) 算出した指標はは以下の通り。 metrics_an2_IT 8.3.3 非交尾期 8.3.3.1 TYがいる日 ID_nm_TY &lt;- data.frame(ID = colnames(mat_RG_nm_TY)) ## 作成 metrics_nm_TY_eigen &lt;- met.eigen(mat_RG_nm_TY, binary = FALSE, sym = TRUE, df = ID_nm_TY, dfid = 1) metrics_nm_TY_strength &lt;- met.strength(mat_RG_nm_TY, df = metrics_nm_TY_eigen, dfid = 1) metrics_nm_TY_between &lt;- met.betweenness(mat_RG_nm_TY, binary = FALSE, sym = TRUE, df = metrics_nm_TY_strength, dfid = 1) ## TYとの親密度などの情報を結合 metrics_nm_TY &lt;- metrics_nm_TY_between %&gt;% left_join(CSI_TY_combined %&gt;% select(subject, CSI_TY), by = c(&quot;ID&quot; = &quot;subject&quot;)) %&gt;% left_join(att %&gt;% filter(study_period == &quot;m18&quot;) %&gt;% select(femaleID, age, rank), by = c(&quot;ID&quot; = &quot;femaleID&quot;)) 算出した指標はは以下の通り。 metrics_nm_TY 8.3.3.2 ITがいる日 ID_nm_IT &lt;- data.frame(ID = colnames(mat_RG_nm_IT)) ## 作成 metrics_nm_IT_eigen &lt;- met.eigen(mat_RG_nm_IT, binary = FALSE, sym = TRUE, df = ID_nm_IT, dfid = 1) metrics_nm_IT_strength &lt;- met.strength(mat_RG_nm_IT, df = metrics_nm_IT_eigen, dfid = 1) metrics_nm_IT_between &lt;- met.betweenness(mat_RG_nm_IT, binary = FALSE, sym = TRUE, df = metrics_nm_IT_strength, dfid = 1) ## ITとの親密度などの情報を結合 metrics_nm_IT &lt;- metrics_nm_IT_between %&gt;% left_join(CSI_IT_combined %&gt;% select(subject, CSI_IT), by = c(&quot;ID&quot; = &quot;subject&quot;)) %&gt;% left_join(att %&gt;% filter(study_period == &quot;m18&quot;) %&gt;% select(femaleID, age, rank), by = c(&quot;ID&quot; = &quot;femaleID&quot;)) 算出した指標はは以下の通り。 metrics_nm_IT 8.4 ネットワークの描画 それでは、ネットワークを描画していきます。 8.4.1 交尾期(非発情・2018~2019) 8.4.1.1 TYがいる日 set.seed(123) mat_RG_an1_TY %&gt;% as_tbl_graph(directed = FALSE) %&gt;% left_join(metrics_an1_TY, by = c(&quot;name&quot; = &quot;ID&quot;)) %&gt;% mutate(sex = if_else(name %in% c(&quot;TY&quot;, &quot;KR&quot;, &quot;LK&quot;), &quot;Male&quot;, &quot;Female&quot;)) %&gt;% ggraph(layout = &quot;nicely&quot;) + geom_node_point(aes(size = eigen, fill = sex), shape = 21, color = &quot;grey23&quot;)+ geom_edge_link(start_cap = circle(0.6,&quot;cm&quot;), end_cap = circle(0.6,&quot;cm&quot;), color = &quot;grey55&quot;, aes(width = weight))+ scale_edge_width_identity(guide = &quot;legend&quot;) + scale_size(range = c(8, 15), breaks = seq(0.2, 1, 0.2), limits = c(0.2, 1)) + geom_node_text(aes(label = name, color = sex)) + theme_graph() + scale_fill_manual(values = c(&quot;grey20&quot;, &quot;white&quot;))+ scale_color_manual(values = c(&quot;white&quot;, &quot;black&quot;)) + theme(aspect.ratio = 0.9)+ scale_x_continuous(expand = c(0.1,0.1)) + scale_y_continuous(expand = c(0.12,0.11)) + labs(size = &quot;Eigenvector centrality&quot;, color = &quot;&quot;, fill = &quot;&quot;, linewidth = &quot;SRI&quot;, title = &quot;Network when *TY* was present (MS18 + MS19)&quot;) + guides(color = &quot;none&quot;, fill = &quot;none&quot;) + theme(text = element_text(family = &quot;Times New Roman&quot;), plot.title = element_markdown(family = &quot;Times New Roman&quot;)) -&gt; net_RG_an1_TY net_RG_an1_TY ggsave(&quot;figures/net_RG_an1_TY.png&quot;, net_RG_an1_TY, width = 200, height = 200, units = &quot;mm&quot;, dpi = 1000) 8.4.1.2 ITがいる日 set.seed(123) mat_RG_an1_IT %&gt;% as_tbl_graph(directed = FALSE) %&gt;% left_join(metrics_an1_IT, by = c(&quot;name&quot; = &quot;ID&quot;)) %&gt;% mutate(sex = if_else(name %in% c(&quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;), &quot;Male&quot;, &quot;Female&quot;)) %&gt;% ggraph(layout = &quot;nicely&quot;) + geom_node_point(aes(size = eigen, fill = sex), shape = 21, color = &quot;grey23&quot;)+ geom_edge_link(start_cap = circle(0.6,&quot;cm&quot;), end_cap = circle(0.6,&quot;cm&quot;), color = &quot;grey55&quot;, aes(width = weight))+ scale_edge_width_identity(guide = &quot;legend&quot;) + scale_size(range = c(8, 15), breaks = seq(0.2, 1, 0.2)) + geom_node_text(aes(label = name, color = sex)) + theme_graph() + scale_fill_manual(values = c(&quot;grey20&quot;, &quot;white&quot;))+ scale_color_manual(values = c(&quot;white&quot;, &quot;black&quot;)) + theme(aspect.ratio = 0.9)+ scale_x_continuous(expand = c(0.1,0.1)) + scale_y_continuous(expand = c(0.12,0.11)) + labs(size = &quot;Eigenvector centrality&quot;, color = &quot;&quot;, fill = &quot;&quot;, linewidth = &quot;SRI&quot;, title = &quot;Network when *IT* was present (MS18 + MS19)&quot;) + guides(color = &quot;none&quot;, fill = &quot;none&quot;) + theme(text = element_text(family = &quot;Times New Roman&quot;), plot.title = element_markdown(family = &quot;Times New Roman&quot;)) -&gt; net_RG_an1_IT net_RG_an1_IT ggsave(&quot;figures/net_RG_an1_IT.png&quot;, net_RG_an1_IT, width = 200, height = 200, units = &quot;mm&quot;, dpi = 1000) 8.4.2 交尾期(非発情・2020~2021) 8.4.2.1 TYがいる日 set.seed(123) mat_RG_an2_TY %&gt;% as_tbl_graph(directed = FALSE) %&gt;% left_join(metrics_an2_TY, by = c(&quot;name&quot; = &quot;ID&quot;)) %&gt;% mutate(sex = if_else(name %in% c(&quot;TY&quot;, &quot;KR&quot;, &quot;LK&quot;), &quot;Male&quot;, &quot;Female&quot;)) %&gt;% ggraph(layout = &quot;nicely&quot;) + geom_node_point(aes(size = eigen, fill = sex), shape = 21, color = &quot;grey23&quot;)+ geom_edge_link(start_cap = circle(0.6,&quot;cm&quot;), end_cap = circle(0.6,&quot;cm&quot;), color = &quot;grey55&quot;, aes(width = weight))+ scale_edge_width_identity(guide = &quot;legend&quot;) + scale_size(range = c(8, 15), breaks = seq(0.2, 1, 0.2)) + geom_node_text(aes(label = name, color = sex)) + theme_graph() + scale_fill_manual(values = c(&quot;grey20&quot;, &quot;white&quot;))+ scale_color_manual(values = c(&quot;white&quot;, &quot;black&quot;)) + theme(aspect.ratio = 0.9)+ scale_x_continuous(expand = c(0.1,0.1)) + scale_y_continuous(expand = c(0.12,0.11)) + labs(size = &quot;Eigenvector centrality&quot;, color = &quot;&quot;, fill = &quot;&quot;, linewidth = &quot;SRI&quot;, title = &quot;Network when *TY* was present (MS20 + MS21)&quot;) + guides(color = &quot;none&quot;, fill = &quot;none&quot;) + theme(text = element_text(family = &quot;Times New Roman&quot;), plot.title = element_markdown(family = &quot;Times New Roman&quot;)) -&gt; net_RG_an2_TY net_RG_an2_TY ggsave(&quot;figures/net_RG_an2_TY.png&quot;, net_RG_an2_TY, width = 200, height = 200, units = &quot;mm&quot;, dpi = 1000) 8.4.2.2 ITがいる日 set.seed(123) mat_RG_an2_IT %&gt;% as_tbl_graph(directed = FALSE) %&gt;% left_join(metrics_an2_IT, by = c(&quot;name&quot; = &quot;ID&quot;)) %&gt;% mutate(sex = if_else(name %in% c(&quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;), &quot;Male&quot;, &quot;Female&quot;)) %&gt;% ggraph(layout = &quot;nicely&quot;) + geom_node_point(aes(size = eigen, fill = sex), shape = 21, color = &quot;grey23&quot;)+ geom_edge_link(start_cap = circle(0.6,&quot;cm&quot;), end_cap = circle(0.6,&quot;cm&quot;), color = &quot;grey55&quot;, aes(width = weight))+ scale_edge_width_identity(guide = &quot;legend&quot;) + scale_size(range = c(8, 15), breaks = seq(0.2, 1, 0.2)) + geom_node_text(aes(label = name, color = sex)) + theme_graph() + scale_fill_manual(values = c(&quot;grey20&quot;, &quot;white&quot;))+ scale_color_manual(values = c(&quot;white&quot;, &quot;black&quot;)) + theme(aspect.ratio = 0.9)+ scale_x_continuous(expand = c(0.1,0.1)) + scale_y_continuous(expand = c(0.12,0.11)) + labs(size = &quot;Eigenvector centrality&quot;, color = &quot;&quot;, fill = &quot;&quot;, linewidth = &quot;SRI&quot;, title = &quot;Network when *IT* was present (MS21)&quot;) + guides(color = &quot;none&quot;, fill = &quot;none&quot;) + theme(text = element_text(family = &quot;Times New Roman&quot;), plot.title = element_markdown(family = &quot;Times New Roman&quot;)) -&gt; net_RG_an2_IT net_RG_an2_IT ggsave(&quot;figures/net_RG_an2_IT.png&quot;, net_RG_an2_IT, width = 200, height = 200, units = &quot;mm&quot;, dpi = 1000) 8.4.3 非交尾期 8.4.3.1 TYがいる日 set.seed(123) mat_RG_nm_TY %&gt;% as_tbl_graph(directed = FALSE) %&gt;% left_join(metrics_nm_TY, by = c(&quot;name&quot; = &quot;ID&quot;)) %&gt;% mutate(sex = if_else(name %in% c(&quot;TY&quot;, &quot;KR&quot;, &quot;LK&quot;), &quot;Male&quot;, &quot;Female&quot;)) %&gt;% ggraph(layout = &quot;nicely&quot;) + geom_node_point(aes(size = eigen, fill = sex), shape = 21, color = &quot;grey23&quot;)+ geom_edge_link(start_cap = circle(0.6,&quot;cm&quot;), end_cap = circle(0.6,&quot;cm&quot;), color = &quot;grey55&quot;, aes(width = weight))+ scale_edge_width_identity(guide = &quot;legend&quot;) + scale_size(range = c(8, 15), breaks = seq(0.2, 1, 0.2), limits = c(0.2, 1)) + geom_node_text(aes(label = name, color = sex)) + theme_graph() + scale_fill_manual(values = c(&quot;grey20&quot;, &quot;white&quot;))+ scale_color_manual(values = c(&quot;white&quot;, &quot;black&quot;)) + theme(aspect.ratio = 0.9)+ scale_x_continuous(expand = c(0.1,0.1)) + scale_y_continuous(expand = c(0.12,0.11)) + labs(size = &quot;Eigenvector centrality&quot;, color = &quot;&quot;, fill = &quot;&quot;, linewidth = &quot;SRI&quot;, title = &quot;Network when *TY* was present (NMS19 + NMS21 + NMS22)&quot;) + guides(color = &quot;none&quot;, fill = &quot;none&quot;) + theme(text = element_text(family = &quot;Times New Roman&quot;), plot.title = element_markdown(family = &quot;Times New Roman&quot;)) -&gt; net_RG_nm_TY net_RG_nm_TY ggsave(&quot;figures/net_RG_nm_TY.png&quot;, net_RG_nm_TY, width = 200, height = 200, units = &quot;mm&quot;, dpi = 1000) 8.4.3.2 ITがいる日 set.seed(123) mat_RG_nm_IT %&gt;% as_tbl_graph(directed = FALSE) %&gt;% left_join(metrics_nm_IT, by = c(&quot;name&quot; = &quot;ID&quot;)) %&gt;% mutate(sex = if_else(name %in% c(&quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;), &quot;Male&quot;, &quot;Female&quot;)) %&gt;% ggraph(layout = &quot;nicely&quot;) + geom_node_point(aes(size = eigen, fill = sex), shape = 21, color = &quot;grey23&quot;)+ geom_edge_link(start_cap = circle(0.6,&quot;cm&quot;), end_cap = circle(0.6,&quot;cm&quot;), color = &quot;grey55&quot;, aes(width = weight))+ scale_edge_width_identity(guide = &quot;legend&quot;) + scale_size(range = c(8, 15), breaks = seq(0.2, 1, 0.2)) + geom_node_text(aes(label = name, color = sex)) + theme_graph() + scale_fill_manual(values = c(&quot;grey20&quot;, &quot;white&quot;))+ scale_color_manual(values = c(&quot;white&quot;, &quot;black&quot;)) + theme(aspect.ratio = 0.9)+ scale_x_continuous(expand = c(0.1,0.1)) + scale_y_continuous(expand = c(0.12,0.11)) + labs(size = &quot;Eigenvector centrality&quot;, color = &quot;&quot;, fill = &quot;&quot;, linewidth = &quot;SRI&quot;, title = &quot;Network when *IT* was present (NMS19 + NMS21)&quot;) + guides(color = &quot;none&quot;, fill = &quot;none&quot;) + theme(text = element_text(family = &quot;Times New Roman&quot;), plot.title = element_markdown(family = &quot;Times New Roman&quot;)) -&gt; net_RG_nm_IT net_RG_nm_IT ggsave(&quot;figures/net_RG_nm_IT.png&quot;, net_RG_nm_IT, width = 200, height = 200, units = &quot;mm&quot;, dpi = 1000) 8.5 ネットワーク指標についての作図 続いて、ネットワーク指標についてのグラフをTY、ITそれぞれについて作成します。 8.5.1 TYについて 8.5.1.1 データの作成 まず、作図のためにネットワーク指標を結合します。 metrics_all_TY &lt;- metrics_an1_TY %&gt;% mutate(study_period = &quot;MS18 + MS19&quot;) %&gt;% bind_rows(metrics_an2_TY %&gt;% mutate(study_period = &quot;MS20 + MS21&quot;)) %&gt;% bind_rows(metrics_nm_TY %&gt;% mutate(study_period = &quot;NMS&quot;)) 8.5.1.2 作図 それでは、作図します。 set.seed(1121) metrics_all_TY %&gt;% mutate(sex = if_else(ID %in% c(&quot;TY&quot;, &quot;KR&quot;, &quot;LK&quot;), &quot;Male&quot;, &quot;Female&quot;)) %&gt;% pivot_longer(col = c(eigen, norm.betweenness), names_to = &quot;type&quot;, values_to = &quot;centrality&quot;) %&gt;% ggplot(aes(x = study_period, y = centrality)) + geom_point(aes(fill = sex, size = sex), position = position_jitter(width = 0.1), shape = 21, alpha = 0.7) + geom_text_repel(data = . %&gt;% filter(sex == &quot;Male&quot;), aes(label = ID), fontface = &quot;italic&quot;, size = 3, family = &quot;Times New Roman&quot;, segment.size = 0, nudge_y = 0.05, nudge_x = 0.2) + scale_fill_manual(values = c(&quot;grey20&quot;, &quot;white&quot;))+ scale_size_manual(values = c(2, 3)) + facet_rep_wrap(~ type, scales = &quot;free&quot;, labeller = as_labeller(c(&quot;eigen&quot; = &quot;Eigenvector centrality&quot;, &quot;norm.betweenness&quot; = &quot;Betweenness&quot;))) + theme_bw(base_size = 12) + theme(text = element_text(family = &quot;Times New Roman&quot;), plot.title = element_markdown(family = &quot;Times New Roman&quot;), strip.background = element_blank(), strip.text = element_text(hjust = 0), aspect.ratio = 0.8) + labs(title = &quot;Network when *TY* was present&quot;, fill = &quot;&quot;, size = &quot;&quot;, x = &quot;&quot;, y = &quot;Centrality&quot;) -&gt; p_metrics_TY p_metrics_TY ggsave(&quot;figures/p_metrics_TY.png&quot;, p_metrics_TY, width = 200, height = 100, units = &quot;mm&quot;, dpi = 1000) 8.5.2 TYについて 8.5.2.1 データの作成 まず、作図のためにネットワーク指標を結合します。 metrics_all_IT &lt;- metrics_an1_IT %&gt;% mutate(study_period = &quot;MS18 + MS19&quot;) %&gt;% bind_rows(metrics_an2_IT %&gt;% mutate(study_period = &quot;MS20&quot;)) %&gt;% bind_rows(metrics_nm_IT %&gt;% mutate(study_period = &quot;NMS&quot;)) 8.5.2.2 作図 それでは、作図します。 set.seed(1121) metrics_all_IT %&gt;% mutate(sex = if_else(ID %in% c(&quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;), &quot;Male&quot;, &quot;Female&quot;)) %&gt;% pivot_longer(col = c(eigen, norm.betweenness), names_to = &quot;type&quot;, values_to = &quot;centrality&quot;) %&gt;% ggplot(aes(x = study_period, y = centrality)) + geom_point(aes(fill = sex, size = sex), position = position_jitter(width = 0.1), shape = 21, alpha = 0.7) + geom_text_repel(data = . %&gt;% filter(sex == &quot;Male&quot;), aes(label = ID), fontface = &quot;italic&quot;, size = 3, family = &quot;Times New Roman&quot;, segment.size = 0, nudge_y = 0.05, nudge_x = 0.1) + scale_fill_manual(values = c(&quot;grey20&quot;, &quot;white&quot;))+ scale_size_manual(values = c(2, 3)) + facet_rep_wrap(~ type, scales = &quot;free&quot;, labeller = as_labeller(c(&quot;eigen&quot; = &quot;Eigenvector centrality&quot;, &quot;norm.betweenness&quot; = &quot;Betweenness&quot;))) + theme_bw(base_size = 12) + theme(text = element_text(family = &quot;Times New Roman&quot;), plot.title = element_markdown(family = &quot;Times New Roman&quot;), strip.background = element_blank(), strip.text = element_text(hjust = 0), aspect.ratio = 0.8) + labs(title = &quot;Network when *IT* was present&quot;, fill = &quot;&quot;, size = &quot;&quot;, x = &quot;&quot;, y = &quot;Centrality&quot;) -&gt; p_metrics_IT p_metrics_IT ggsave(&quot;figures/p_metrics_IT.png&quot;, p_metrics_IT, width = 200, height = 100, units = &quot;mm&quot;, dpi = 1000) 8.6 統計的分析 8.6.1 オスがいる日といない日の比較 オスがいる日といない日でネットワークがどのように異なるかを調べます。具体的には、モジュラリティ―の比較を行います。 8.6.1.1 オスがいない日のネットワークの作成 まずは、オスがいない日のデータのみを用いてネットワークを作成します。 8.6.1.1.1 交尾期(非発情・2018~2019) 8.6.1.1.1.1 TYがいない日 focal_RG_an1_noTY &lt;- focal_RG %&gt;% filter(rs2 == 0) %&gt;% filter(study_period %in% c(&quot;m18&quot;, &quot;m19&quot;)) %&gt;% filter(TY_presence == 0) %&gt;% select(one_of(female_1st), KR, LK) ## 作成 mat_RG_an1_noTY &lt;- get_network(focal_RG_an1_noTY, data_format = &quot;GBI&quot;, association_index = &quot;SRI&quot;) ## Generating 18 x 18 matrix 隣接行列は以下の通り。 mat_RG_an1_noTY %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot; &quot;) 8.6.1.1.1.2 ITがいる日 focal_RG_an1_noIT &lt;- focal_RG %&gt;% filter(rs2 == 0) %&gt;% filter(study_period %in% c(&quot;m18&quot;, &quot;m19&quot;)) %&gt;% filter(IT_presence == 0) %&gt;% select(one_of(female_1st), KR, LK) ## 作成 mat_RG_an1_noIT &lt;- get_network(focal_RG_an1_noIT, data_format = &quot;GBI&quot;, association_index = &quot;SRI&quot;) ## Generating 18 x 18 matrix 隣接行列は以下の通り。 mat_RG_an1_noIT %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot; &quot;) 8.6.1.1.2 交尾期(非発情・2020~2021) 8.6.1.1.2.1 TYがいる日 focal_RG_an2_noTY &lt;- focal_RG %&gt;% filter(rs2 == 0) %&gt;% filter(study_period %in% c(&quot;m20&quot;, &quot;m21&quot;)) %&gt;% filter(TY_presence == 0) %&gt;% select(one_of(female_2nd), KR) ## 作成 mat_RG_an2_noTY &lt;- get_network(focal_RG_an2_noTY, data_format = &quot;GBI&quot;, association_index = &quot;SRI&quot;) ## Generating 8 x 8 matrix 隣接行列は以下の通り。 mat_RG_an2_noTY %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot; &quot;) 8.6.1.1.2.2 ITがいる日 focal_RG_an2_noIT &lt;- focal_RG %&gt;% filter(rs2 == 0) %&gt;% filter(study_period %in% c(&quot;m20&quot;, &quot;m21&quot;)) %&gt;% filter(IT_presence == 0) %&gt;% select(one_of(female_2nd), KR) ## 作成 mat_RG_an2_noIT &lt;- get_network(focal_RG_an2_noIT, data_format = &quot;GBI&quot;, association_index = &quot;SRI&quot;) ## Generating 8 x 8 matrix 隣接行列は以下の通り。 mat_RG_an1_noIT %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot; &quot;) 8.6.1.1.3 非交尾期 8.6.1.1.3.1 TYがいる日 focal_RG_nm_noTY &lt;- focal_RG %&gt;% filter(study_period %in% c(&quot;nm19&quot;, &quot;nm20&quot;, &quot;nm21&quot;, &quot;nm22&quot;)) %&gt;% filter(TY_presence == 0) %&gt;% select(one_of(female_1st), KR, -Tam) ## 作成 mat_RG_nm_noTY &lt;- get_network(focal_RG_nm_noTY, data_format = &quot;GBI&quot;, association_index = &quot;SRI&quot;) ## Generating 16 x 16 matrix 隣接行列は以下の通り。 mat_RG_nm_noTY %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot; &quot;) 8.6.1.1.3.2 ITがいない日 focal_RG_nm_noIT &lt;- focal_RG %&gt;% filter(study_period %in% c(&quot;nm19&quot;, &quot;nm20&quot;, &quot;nm21&quot;)) %&gt;% filter(IT_presence == 0) %&gt;% select(one_of(female_1st), KR, -Tam) ## 作成 mat_RG_nm_noIT &lt;- get_network(focal_RG_nm_noIT, data_format = &quot;GBI&quot;, association_index = &quot;SRI&quot;) ## Generating 16 x 16 matrix 隣接行列は以下の通り。 mat_RG_nm_noIT %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot; &quot;) 8.6.1.2 モジュラリティ―の算出 8.6.1.2.1 TY・交尾期(非発情・2018~2019) 8.6.1.2.1.1 TYがいる日 モジュラリティ―を算出します。 graph_RG_an1_TY &lt;- graph_from_adjacency_matrix(mat_RG_an1_TY, ## 有向グラフなら &quot;directed&quot; mode= &quot;undirected&quot;, ## 重みなしなら NULL weighted = TRUE) cluster_optimal(graph_RG_an1_TY, weights = E(graph_RG_an1_TY)$weight) -&gt; cluster_RG_an1_TY クラスターのグループ分けは以下の通り。 cluster_RG_an1_TY ## IGRAPH clustering optimal, groups: 3, mod: 0.13 ## + groups: ## $`1` ## [1] &quot;Mik&quot; &quot;Tam&quot; &quot;Ten&quot; &quot;Tot&quot; &quot;Mal&quot; &quot;LK&quot; ## ## $`2` ## [1] &quot;Kil&quot; &quot;Koh&quot; &quot;Kol&quot; &quot;Kit&quot; &quot;Kun&quot; &quot;TY&quot; ## ## $`3` ## [1] &quot;Aka&quot; &quot;Ntr&quot; &quot;Hen&quot; &quot;Hot&quot; &quot;Mei&quot; &quot;Ako&quot; &quot;KR&quot; ## モジュラリティは以下の通り。 modularity(cluster_RG_an1_TY, directed = FALSE, weights = NULL) ## [1] 0.1265072 8.6.1.2.1.2 TYがいない日 graph_RG_an1_noTY &lt;- graph_from_adjacency_matrix(mat_RG_an1_noTY, ## 有向グラフなら &quot;directed&quot; mode= &quot;undirected&quot;, ## 重みなしなら NULL weighted = TRUE) cluster_optimal(graph_RG_an1_noTY, weights = E(graph_RG_an1_noTY)$weight) -&gt; cluster_RG_an1_noTY クラスターのグループ分けは以下の通り。 cluster_RG_an1_noTY ## IGRAPH clustering optimal, groups: 4, mod: 0.26 ## + groups: ## $`1` ## [1] &quot;Mik&quot; &quot;Hen&quot; &quot;Hot&quot; &quot;Mei&quot; &quot;Mal&quot; ## ## $`2` ## [1] &quot;Kil&quot; &quot;Koh&quot; &quot;Kit&quot; &quot;Kun&quot; ## ## $`3` ## [1] &quot;Tam&quot; &quot;Ntr&quot; &quot;Ten&quot; &quot;Tot&quot; &quot;Kol&quot; &quot;KR&quot; &quot;LK&quot; ## ## $`4` ## + ... omitted several groups/vertices モジュラリティは以下の通り。 modularity(cluster_RG_an1_noTY, directed = FALSE, weights = NULL) ## [1] 0.2625986 8.6.1.2.2 TY・交尾期(非発情・2020~2021) 8.6.1.2.2.1 TYがいる日 モジュラリティ―を算出します。 graph_RG_an2_TY &lt;- graph_from_adjacency_matrix(mat_RG_an2_TY, ## 有向グラフなら &quot;directed&quot; mode= &quot;undirected&quot;, ## 重みなしなら NULL weighted = TRUE) cluster_optimal(graph_RG_an2_TY, weights = E(graph_RG_an2_TY)$weight) -&gt; cluster_RG_an2_TY クラスターのグループ分けは以下の通り。 cluster_RG_an2_TY ## IGRAPH clustering optimal, groups: 2, mod: 0.073 ## + groups: ## $`1` ## [1] &quot;Kil&quot; &quot;Aka&quot; &quot;TY&quot; &quot;KR&quot; ## ## $`2` ## [1] &quot;Ntr&quot; &quot;Ten&quot; &quot;Hot&quot; &quot;Kol&quot; &quot;Mal&quot; ## モジュラリティは以下の通り。 modularity(cluster_RG_an2_TY, directed = FALSE, weights = NULL) ## [1] 0.07288184 8.6.1.2.2.2 TYがいない日 graph_RG_an2_noTY &lt;- graph_from_adjacency_matrix(mat_RG_an2_noTY, ## 有向グラフなら &quot;directed&quot; mode= &quot;undirected&quot;, ## 重みなしなら NULL weighted = TRUE) cluster_optimal(graph_RG_an2_noTY, weights = E(graph_RG_an2_noTY)$weight) -&gt; cluster_RG_an2_noTY クラスターのグループ分けは以下の通り。 cluster_RG_an2_noTY ## IGRAPH clustering optimal, groups: 2, mod: 0.11 ## + groups: ## $`1` ## [1] &quot;Kil&quot; &quot;Ntr&quot; &quot;Kol&quot; &quot;Mal&quot; &quot;Aka&quot; ## ## $`2` ## [1] &quot;Ten&quot; &quot;Hot&quot; &quot;KR&quot; ## モジュラリティは以下の通り。 modularity(cluster_RG_an2_noTY, directed = FALSE, weights = NULL) ## [1] 0.1134544 8.6.1.2.3 TY・非交尾期 8.6.1.2.3.1 TYがいる日 モジュラリティ―を算出します。 graph_RG_nm_TY &lt;- graph_from_adjacency_matrix(mat_RG_nm_TY, ## 有向グラフなら &quot;directed&quot; mode= &quot;undirected&quot;, ## 重みなしなら NULL weighted = TRUE) cluster_optimal(graph_RG_nm_TY, weights = E(graph_RG_nm_TY)$weight) -&gt; cluster_RG_nm_TY クラスターのグループ分けは以下の通り。 cluster_RG_nm_TY ## IGRAPH clustering optimal, groups: 4, mod: 0.13 ## + groups: ## $`1` ## [1] &quot;Mik&quot; &quot;Hen&quot; &quot;Hot&quot; &quot;Mei&quot; &quot;Mal&quot; &quot;KR&quot; ## ## $`2` ## [1] &quot;Kil&quot; &quot;Koh&quot; &quot;Kol&quot; &quot;Kit&quot; &quot;Kun&quot; &quot;TY&quot; ## ## $`3` ## [1] &quot;Aka&quot; &quot;Ako&quot; ## ## $`4` ## + ... omitted several groups/vertices モジュラリティは以下の通り。 modularity(cluster_RG_nm_TY, directed = FALSE, weights = NULL) ## [1] 0.1349223 8.6.1.2.3.2 TYがいない日 graph_RG_nm_noTY &lt;- graph_from_adjacency_matrix(mat_RG_nm_noTY, ## 有向グラフなら &quot;directed&quot; mode= &quot;undirected&quot;, ## 重みなしなら NULL weighted = TRUE) cluster_optimal(graph_RG_nm_noTY, weights = E(graph_RG_nm_noTY)$weight) -&gt; cluster_RG_nm_noTY クラスターのグループ分けは以下の通り。 cluster_RG_nm_noTY ## IGRAPH clustering optimal, groups: 9, mod: 0.45 ## + groups: ## $`1` ## [1] &quot;Mik&quot; &quot;Tot&quot; &quot;Mei&quot; &quot;Kol&quot; &quot;Mal&quot; &quot;KR&quot; ## ## $`2` ## [1] &quot;Kil&quot; ## ## $`3` ## [1] &quot;Koh&quot; ## ## $`4` ## + ... omitted several groups/vertices モジュラリティは以下の通り。 modularity(cluster_RG_nm_noTY, directed = FALSE, weights = NULL) ## [1] 0.4549169 8.6.1.2.4 IT・交尾期(非発情・2018~2019) 8.6.1.2.4.1 ITがいる日 モジュラリティ―を算出します。 graph_RG_an1_IT &lt;- graph_from_adjacency_matrix(mat_RG_an1_IT, ## 有向グラフなら &quot;directed&quot; mode= &quot;undirected&quot;, ## 重みなしなら NULL weighted = TRUE) cluster_optimal(graph_RG_an1_IT, weights = E(graph_RG_an1_IT)$weight) -&gt; cluster_RG_an1_IT クラスターのグループ分けは以下の通り。 cluster_RG_an1_IT ## IGRAPH clustering optimal, groups: 3, mod: 0.21 ## + groups: ## $`1` ## [1] &quot;Mik&quot; &quot;Tam&quot; &quot;Ten&quot; &quot;Tot&quot; &quot;Mal&quot; &quot;LK&quot; ## ## $`2` ## [1] &quot;Kil&quot; &quot;Koh&quot; &quot;Kol&quot; &quot;Kit&quot; &quot;Kun&quot; &quot;IT&quot; ## ## $`3` ## [1] &quot;Aka&quot; &quot;Ntr&quot; &quot;Hen&quot; &quot;Hot&quot; &quot;Mei&quot; &quot;Ako&quot; &quot;KR&quot; ## モジュラリティは以下の通り。 modularity(cluster_RG_an1_IT, directed = FALSE, weights = NULL) ## [1] 0.2056144 8.6.1.2.4.2 ITがいない日 graph_RG_an1_noIT &lt;- graph_from_adjacency_matrix(mat_RG_an1_noIT, ## 有向グラフなら &quot;directed&quot; mode= &quot;undirected&quot;, ## 重みなしなら NULL weighted = TRUE) cluster_optimal(graph_RG_an1_noIT, weights = E(graph_RG_an1_noIT)$weight) -&gt; cluster_RG_an1_noIT クラスターのグループ分けは以下の通り。 cluster_RG_an1_noIT ## IGRAPH clustering optimal, groups: 3, mod: 0.14 ## + groups: ## $`1` ## [1] &quot;Mik&quot; &quot;Aka&quot; &quot;Ntr&quot; &quot;Hen&quot; &quot;Mei&quot; &quot;Ako&quot; &quot;Mal&quot; &quot;KR&quot; ## ## $`2` ## [1] &quot;Kil&quot; &quot;Koh&quot; &quot;Kit&quot; &quot;Kun&quot; ## ## $`3` ## [1] &quot;Tam&quot; &quot;Ten&quot; &quot;Tot&quot; &quot;Hot&quot; &quot;Kol&quot; &quot;LK&quot; ## モジュラリティは以下の通り。 modularity(cluster_RG_an1_noIT, directed = FALSE, weights = NULL) ## [1] 0.1427564 8.6.1.2.5 IT・交尾期(非発情・2020~2021) 8.6.1.2.5.1 ITがいる日 モジュラリティ―を算出します。 graph_RG_an2_IT &lt;- graph_from_adjacency_matrix(mat_RG_an2_IT, ## 有向グラフなら &quot;directed&quot; mode= &quot;undirected&quot;, ## 重みなしなら NULL weighted = TRUE) cluster_optimal(graph_RG_an2_IT, weights = E(graph_RG_an2_IT)$weight) -&gt; cluster_RG_an2_IT クラスターのグループ分けは以下の通り。 cluster_RG_an2_IT ## IGRAPH clustering optimal, groups: 3, mod: 0.18 ## + groups: ## $`1` ## [1] &quot;Kil&quot; &quot;Ntr&quot; &quot;Kol&quot; &quot;Aka&quot; &quot;IT&quot; ## ## $`2` ## [1] &quot;Ten&quot; &quot;Hot&quot; ## ## $`3` ## [1] &quot;Mal&quot; &quot;KR&quot; ## モジュラリティは以下の通り。 modularity(cluster_RG_an2_IT, directed = FALSE, weights = NULL) ## [1] 0.184775 8.6.1.2.5.2 ITがいない日 graph_RG_an2_noIT &lt;- graph_from_adjacency_matrix(mat_RG_an2_noIT, ## 有向グラフなら &quot;directed&quot; mode= &quot;undirected&quot;, ## 重みなしなら NULL weighted = TRUE) cluster_optimal(graph_RG_an2_noIT, weights = E(graph_RG_an2_noIT)$weight) -&gt; cluster_RG_an2_noIT クラスターのグループ分けは以下の通り。 cluster_RG_an2_noIT ## IGRAPH clustering optimal, groups: 3, mod: 0.034 ## + groups: ## $`1` ## [1] &quot;Kil&quot; &quot;Ntr&quot; &quot;Ten&quot; &quot;Kol&quot; ## ## $`2` ## [1] &quot;Hot&quot; &quot;Mal&quot; ## ## $`3` ## [1] &quot;Aka&quot; &quot;KR&quot; ## モジュラリティは以下の通り。 modularity(cluster_RG_an2_noIT, directed = FALSE, weights = NULL) ## [1] 0.03356692 8.6.1.2.6 IT・非交尾期 8.6.1.2.6.1 TYがいる日 モジュラリティ―を算出します。 graph_RG_nm_IT &lt;- graph_from_adjacency_matrix(mat_RG_nm_IT, ## 有向グラフなら &quot;directed&quot; mode= &quot;undirected&quot;, ## 重みなしなら NULL weighted = TRUE) cluster_optimal(graph_RG_nm_IT, weights = E(graph_RG_nm_IT)$weight) -&gt; cluster_RG_nm_IT クラスターのグループ分けは以下の通り。 cluster_RG_nm_IT ## IGRAPH clustering optimal, groups: 4, mod: 0.2 ## + groups: ## $`1` ## [1] &quot;Mik&quot; &quot;Ntr&quot; &quot;Ten&quot; &quot;Tot&quot; &quot;Mei&quot; &quot;Kol&quot; &quot;Mal&quot; &quot;KR&quot; ## ## $`2` ## [1] &quot;Kil&quot; &quot;Koh&quot; &quot;Kit&quot; &quot;Kun&quot; ## ## $`3` ## [1] &quot;Aka&quot; &quot;Ako&quot; ## ## $`4` ## + ... omitted several groups/vertices モジュラリティは以下の通り。 modularity(cluster_RG_nm_IT, directed = FALSE, weights = NULL) ## [1] 0.2027807 8.6.1.2.6.2 ITがいない日 graph_RG_nm_noIT &lt;- graph_from_adjacency_matrix(mat_RG_nm_noIT, ## 有向グラフなら &quot;directed&quot; mode= &quot;undirected&quot;, ## 重みなしなら NULL weighted = TRUE) cluster_optimal(graph_RG_nm_noIT, weights = E(graph_RG_nm_noIT)$weight) -&gt; cluster_RG_nm_noIT クラスターのグループ分けは以下の通り。 cluster_RG_nm_noIT ## IGRAPH clustering optimal, groups: 10, mod: 0.43 ## + groups: ## $`1` ## [1] &quot;Mik&quot; ## ## $`2` ## [1] &quot;Kil&quot; ## ## $`3` ## [1] &quot;Koh&quot; &quot;Aka&quot; &quot;Ntr&quot; &quot;Ako&quot; &quot;Kol&quot; &quot;Kun&quot; ## ## $`4` ## + ... omitted several groups/vertices モジュラリティは以下の通り。 modularity(cluster_RG_nm_noIT, directed = FALSE, weights = NULL) ## [1] 0.4286417 8.6.2 オスとのCSIと中心性の関連 続いて、休息集団ネットワーク内のメスの固有ベクトル中心性とオスとの親密度の関連について調べます。 8.6.2.1 交尾期(非発情・2018~2019) 8.6.2.1.1 TYがいる日 8.6.2.1.1.1 モデリング まず、実際のネットワークを用いてGLMを実行します。 ## データの作成 ### 血縁個体数の算出 no_kin_an1_TY &lt;- tidyr::crossing(femaleID = metrics_an1_TY$ID, femaleID2 = metrics_an1_TY$ID) %&gt;% filter(!femaleID %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;), !femaleID2 %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;)) %&gt;% left_join(kin) %&gt;% drop_na(kin) %&gt;% group_by(femaleID) %&gt;% summarise(no_kin = sum(kin &gt;= 0.0625)) %&gt;% ungroup() ### データの整形と結合 glmdata_an1_TY &lt;- metrics_all_TY %&gt;% filter(study_period == &quot;MS18 + MS19&quot;) %&gt;% arrange(rank) %&gt;% mutate(rank = 1:n()) %&gt;% select(ID, eigen, rank, CSI_TY) %&gt;% left_join(no_kin_an1_TY, by = c(&quot;ID&quot; = &quot;femaleID&quot;)) ## モデルの実行 m_an1_TY_eigen &lt;- brm(data = glmdata_an1_TY, formula = eigen ~ CSI_TY + no_kin + rank, family = zero_one_inflated_beta(), prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), prior(student_t(4,0,15), class = &quot;Intercept&quot;)), silent = 2, refresh = 0, backend = &quot;cmdstanr&quot;, file = &quot;model/m_an1_TY_eigen&quot;) 結果は以下の通りです。 model_parameters(m_an1_TY_eigen) 続いて、500回ノードラベルパーミュテーションを行い、それぞれの係数を取得します。 # b_CSI_TY_an1 &lt;- rep(0, 500) # b_no_kin_an1_TY &lt;- rep(0, 500) # b_rank_an1_TY &lt;- rep(0, 500) # # set.seed(123) # pb = txtProgressBar(min = 1, max = 500, style = 3) # # for(i in 1:500){ # setTxtProgressBar(pb, i) # random_net_an1_TY &lt;- rmperm(mat_RG_an1_TY) # colnames(random_net_an1_TY) &lt;- colnames(mat_RG_an1_TY) # rownames(random_net_an1_TY) &lt;- rownames(mat_RG_an1_TY) # # ID_an1_TY_eigen_rand &lt;- met.eigen(random_net_an1_TY, # binary = FALSE, # sym = TRUE, # df = glmdata_an1_TY %&gt;% select(-eigen), # dfid = 1) %&gt;% # filter(!ID %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;)) # # m_an1_TY_eigen_rand &lt;- brm(data = ID_an1_TY_eigen_rand, # formula = eigen ~ CSI_TY + no_kin + rank, # family = zero_one_inflated_beta(), # prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), # prior(student_t(4,0,15), class = &quot;Intercept&quot;)), # silent = 2, # refresh = 0, # backend = &quot;cmdstanr&quot;) # # b_CSI_TY_an1[i] &lt;- fixef(m_an1_TY_eigen_rand)[2,1] # b_no_kin_an1_TY[i] &lt;- fixef(m_an1_TY_eigen_rand)[3,1] # b_rank_an1_TY[i] &lt;- fixef(m_an1_TY_eigen_rand)[4,1] # } ## 保存 # saveRDS(b_CSI_TY_an1, &quot;data/b_CSI_TY_an1.rds&quot;) # saveRDS(b_no_kin_an1_TY, &quot;data/b_no_kin_an1_TY.rds&quot;) # saveRDS(b_rank_an1_TY, &quot;data/b_rank_an1_TY.rds&quot;) ## 読み込み b_CSI_TY_an1 &lt;- readRDS(&quot;data/b_CSI_TY_an1.rds&quot;) b_no_kin_an1_TY &lt;- readRDS(&quot;data/b_no_kin_an1_TY.rds&quot;) b_rank_an1_TY &lt;- readRDS(&quot;data/b_rank_an1_TY.rds&quot;) 8.6.2.1.1.2 結果の確認 結果の表を作成します。 summary_an1_TY_eigen &lt;- summary(m_an1_TY_eigen) model_parameters(m_an1_TY_eigen, ci = 0.95,dispersion = TRUE, centrality = &quot;median&quot;, ci_method = &quot;eti&quot;) %&gt;% filter(Parameter != &quot;phi&quot;) %&gt;% data.frame() %&gt;% dplyr::select(1, 3,4, 9) %&gt;% mutate(&quot;Bulk ESS&quot; = summary_an1_TY_eigen$fixed$Bulk_ESS, &quot;Tail ESS&quot; = summary_an1_TY_eigen$fixed$Tail_ESS) %&gt;% mutate(`P left` = c(NA, mean(fixef(m_an1_TY_eigen)[2,1] &lt; b_CSI_TY_an1), mean(fixef(m_an1_TY_eigen)[3,1] &lt; b_no_kin_an1_TY), mean(fixef(m_an1_TY_eigen)[4,1] &lt; b_rank_an1_TY))) %&gt;% mutate(`P right` = c(NA, mean(fixef(m_an1_TY_eigen)[2,1] &gt; b_CSI_TY_an1), mean(fixef(m_an1_TY_eigen)[3,1] &gt; b_no_kin_an1_TY), mean(fixef(m_an1_TY_eigen)[4,1] &gt; b_rank_an1_TY))) %&gt;% select(1, 2, 3, 7, 8, everything()) %&gt;% mutate(Parameter = str_replace_all(Parameter, c(&quot;b_Intercept&quot;=&quot;Intercept&quot;, &quot;b_CSI_TY&quot; = &quot;CSI with TY&quot;, &quot;b_no_kin&quot; = &quot;No. of kin females in network&quot;, &quot;b_rank&quot; = &quot;Ordinal rank&quot;))) %&gt;% rename(&quot;Explanatory variables&quot; = &quot;Parameter&quot;) %&gt;% mutate(across(where(is.numeric), ~sprintf(&quot;%.2f&quot;, .))) -&gt; table_an1_TY_eigen table_an1_TY_eigen write_csv(table_an1_TY_eigen, &quot;tables/table_an1_TY_eigen.csv&quot;) 8.6.2.1.1.3 結果の作図 最後に結果を作図します。 pred_an1_TY_eigen &lt;- predict_response(m_an1_TY_eigen, terms = &quot;CSI_TY[0:5, by = 0.1]&quot;) %&gt;% data.frame() glmdata_an1_TY %&gt;% ggplot(aes(x = CSI_TY, y = eigen)) + geom_line(data = pred_an1_TY_eigen, aes(x = x, y = predicted)) + geom_ribbon(data = pred_an1_TY_eigen, aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high), alpha = 0.2) + geom_point(shape = 1, size = 3) + theme_bw(base_size = 12) + labs(x = &quot;CSI with *TY*&quot;, y = &quot;Eigenvector centrality&quot;, title = &quot;Network when *TY* was present (MS18 + MS19)&quot;) + theme(aspect.ratio = 1, text = element_text(family = &quot;Times New Roman&quot;), plot.title = element_markdown(family = &quot;Times New Roman&quot;, size = 10), axis.title.x = element_markdown()) -&gt; p_an1_TY_eigen p_an1_TY_eigen ggsave(&quot;figures/p_an1_TY_eigen.png&quot;, p_an1_TY_eigen, width = 100, height = 100, units = &quot;mm&quot;, dpi = 1000) 8.6.2.1.2 ITがいる日 8.6.2.1.2.1 モデリング まず、実際のネットワークを用いてGLMを実行します。 ###### モデリング まず、実際のネットワークを用いてGLMを実行します。 ## データの作成 ### 血縁個体数の算出 no_kin_an1_IT &lt;- tidyr::crossing(femaleID = metrics_an1_IT$ID, femaleID2 = metrics_an1_IT$ID) %&gt;% filter(!femaleID %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;), !femaleID2 %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;)) %&gt;% left_join(kin) %&gt;% drop_na(kin) %&gt;% group_by(femaleID) %&gt;% summarise(no_kin = sum(kin &gt;= 0.0625)) %&gt;% ungroup() ### データの整形と結合 glmdata_an1_IT &lt;- metrics_all_IT %&gt;% filter(study_period == &quot;MS18 + MS19&quot;) %&gt;% arrange(rank) %&gt;% mutate(rank = 1:n()) %&gt;% select(ID, eigen, rank, CSI_IT) %&gt;% left_join(no_kin_an1_IT, by = c(&quot;ID&quot; = &quot;femaleID&quot;)) ## モデルの実行 m_an1_IT_eigen &lt;- brm(data = glmdata_an1_IT, formula = eigen ~ CSI_IT + no_kin + rank, family = zero_one_inflated_beta(), prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), prior(student_t(4,0,15), class = &quot;Intercept&quot;)), silent = 2, refresh = 0, backend = &quot;cmdstanr&quot;, file = &quot;model/m_an1_IT_eigen&quot;) 結果は以下の通りです。 model_parameters(m_an1_IT_eigen) 続いて、500回ノードラベルパーミュテーションを行い、それぞれの係数を取得します。 # b_CSI_IT_an1 &lt;- rep(0, 500) # b_no_kin_an1_IT &lt;- rep(0, 500) # b_rank_an1_IT &lt;- rep(0, 500) # # set.seed(123) # pb = txtProgressBar(min = 1, max = 500, style = 3) # # for(i in 1:500){ # setTxtProgressBar(pb, i) # random_net_an1_IT &lt;- rmperm(mat_RG_an1_IT) # colnames(random_net_an1_IT) &lt;- colnames(mat_RG_an1_IT) # rownames(random_net_an1_IT) &lt;- rownames(mat_RG_an1_IT) # # ID_an1_IT_eigen_rand &lt;- met.eigen(random_net_an1_IT, # binary = FALSE, # sym = TRUE, # df = glmdata_an1_IT %&gt;% select(-eigen), # dfid = 1) %&gt;% # filter(!ID %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;)) # # m_an1_IT_eigen_rand &lt;- brm(data = ID_an1_IT_eigen_rand, # formula = eigen ~ CSI_IT + no_kin + rank, # family = zero_one_inflated_beta(), # prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), # prior(student_t(4,0,15), class = &quot;Intercept&quot;)), # silent = 2, # refresh = 0, # backend = &quot;cmdstanr&quot;) # # b_CSI_IT_an1[i] &lt;- fixef(m_an1_IT_eigen_rand)[2,1] # b_no_kin_an1_IT[i] &lt;- fixef(m_an1_IT_eigen_rand)[3,1] # b_rank_an1_IT[i] &lt;- fixef(m_an1_IT_eigen_rand)[4,1] # } ## 保存 # saveRDS(b_CSI_IT_an1, &quot;data/b_CSI_IT_an1.rds&quot;) # saveRDS(b_no_kin_an1_IT, &quot;data/b_no_kin_an1_IT.rds&quot;) # saveRDS(b_rank_an1_IT, &quot;data/b_rank_an1_IT.rds&quot;) ## 読み込み b_CSI_IT_an1 &lt;- readRDS(&quot;data/b_CSI_IT_an1.rds&quot;) b_no_kin_an1_IT &lt;- readRDS(&quot;data/b_no_kin_an1_IT.rds&quot;) b_rank_an1_IT &lt;- readRDS(&quot;data/b_rank_an1_IT.rds&quot;) 8.6.2.1.2.2 結果の確認 結果の表を作成します。 summary_an1_IT_eigen &lt;- summary(m_an1_IT_eigen) model_parameters(m_an1_IT_eigen, ci = 0.95,dispersion = TRUE, centrality = &quot;median&quot;, ci_method = &quot;eti&quot;) %&gt;% filter(Parameter != &quot;phi&quot;) %&gt;% data.frame() %&gt;% dplyr::select(1, 3,4, 9) %&gt;% mutate(&quot;Bulk ESS&quot; = summary_an1_IT_eigen$fixed$Bulk_ESS, &quot;Tail ESS&quot; = summary_an1_IT_eigen$fixed$Tail_ESS) %&gt;% mutate(`P left` = c(NA, mean(fixef(m_an1_IT_eigen)[2,1] &lt; b_CSI_IT_an1), mean(fixef(m_an1_IT_eigen)[3,1] &lt; b_no_kin_an1_IT), mean(fixef(m_an1_IT_eigen)[4,1] &lt; b_rank_an1_IT))) %&gt;% mutate(`P right` = c(NA, mean(fixef(m_an1_IT_eigen)[2,1] &gt; b_CSI_IT_an1), mean(fixef(m_an1_IT_eigen)[3,1] &gt; b_no_kin_an1_IT), mean(fixef(m_an1_IT_eigen)[4,1] &gt; b_rank_an1_IT))) %&gt;% select(1, 2, 3, 7, 8, everything()) %&gt;% mutate(Parameter = str_replace_all(Parameter, c(&quot;b_Intercept&quot;=&quot;Intercept&quot;, &quot;b_CSI_IT&quot; = &quot;CSI with IT&quot;, &quot;b_no_kin&quot; = &quot;No. of kin females in network&quot;, &quot;b_rank&quot; = &quot;Ordinal rank&quot;))) %&gt;% rename(&quot;Explanatory variables&quot; = &quot;Parameter&quot;) %&gt;% mutate(across(where(is.numeric), ~sprintf(&quot;%.2f&quot;, .))) -&gt; table_an1_IT_eigen table_an1_IT_eigen write_csv(table_an1_IT_eigen, &quot;tables/table_an1_IT_eigen.csv&quot;) 8.6.2.1.2.3 結果の作図 最後に結果を作図します。 pred_an1_IT_eigen &lt;- predict_response(m_an1_IT_eigen, terms = &quot;CSI_IT[0:4, by = 0.1]&quot;) %&gt;% data.frame() glmdata_an1_IT %&gt;% ggplot(aes(x = CSI_IT, y = eigen)) + geom_line(data = pred_an1_IT_eigen, aes(x = x, y = predicted)) + geom_ribbon(data = pred_an1_IT_eigen, aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high), alpha = 0.2) + geom_point(shape = 1, size = 3) + theme_bw(base_size = 12) + labs(x = &quot;CSI with *IT*&quot;, y = &quot;Eigenvector centraliIT&quot;, title = &quot;Network when *IT* was present (MS18 + MS19)&quot;) + theme(aspect.ratio = 1, text = element_text(family = &quot;Times New Roman&quot;), plot.title = element_markdown(family = &quot;Times New Roman&quot;, size = 10), axis.title.x = element_markdown()) -&gt; p_an1_IT_eigen p_an1_IT_eigen ggsave(&quot;figures/p_an1_IT_eigen.png&quot;, p_an1_IT_eigen, width = 100, height = 100, units = &quot;mm&quot;, dpi = 1000) 8.6.2.2 交尾期(非発情・2020~2021) 8.6.2.2.1 TYがいる日 8.6.2.2.1.1 モデリング まず、実際のネットワークを用いてGLMを実行します。 ## データの作成 ### 血縁個体数の算出 no_kin_an2_TY &lt;- tidyr::crossing(femaleID = metrics_an2_TY$ID, femaleID2 = metrics_an2_TY$ID) %&gt;% filter(!femaleID %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;), !femaleID2 %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;)) %&gt;% left_join(kin) %&gt;% drop_na(kin) %&gt;% group_by(femaleID) %&gt;% summarise(no_kin = sum(kin &gt;= 0.0625)) %&gt;% ungroup() ### データの整形と結合 glmdata_an2_TY &lt;- metrics_all_TY %&gt;% filter(study_period == &quot;MS20 + MS21&quot;) %&gt;% arrange(rank) %&gt;% mutate(rank = 1:n()) %&gt;% select(ID, eigen, rank, CSI_TY) %&gt;% left_join(no_kin_an2_TY, by = c(&quot;ID&quot; = &quot;femaleID&quot;)) ## モデルの実行 m_an2_TY_eigen &lt;- brm(data = glmdata_an2_TY, formula = eigen ~ CSI_TY + rank, family = zero_one_inflated_beta(), prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), prior(student_t(4,0,15), class = &quot;Intercept&quot;)), silent = 2, refresh = 0, backend = &quot;cmdstanr&quot;, file = &quot;model/m_an2_TY_eigen&quot;) 結果は以下の通りです。 model_parameters(m_an2_TY_eigen) 続いて、500回ノードラベルパーミュテーションを行い、それぞれの係数を取得します。 # b_CSI_TY_an2 &lt;- rep(0, 500) # b_rank_an2_TY &lt;- rep(0, 500) # # set.seed(123) # pb = txtProgressBar(min = 1, max = 500, style = 3) # # for(i in 1:500){ # setTxtProgressBar(pb, i) # random_net_an2_TY &lt;- rmperm(mat_RG_an2_TY) # colnames(random_net_an2_TY) &lt;- colnames(mat_RG_an2_TY) # rownames(random_net_an2_TY) &lt;- rownames(mat_RG_an2_TY) # # ID_an2_TY_eigen_rand &lt;- met.eigen(random_net_an2_TY, # binary = FALSE, # sym = TRUE, # df = glmdata_an2_TY %&gt;% select(-eigen), # dfid = 1) %&gt;% # filter(!ID %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;)) # # m_an2_TY_eigen_rand &lt;- brm(data = ID_an2_TY_eigen_rand, # formula = eigen ~ CSI_TY + rank, # family = zero_one_inflated_beta(), # prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), # prior(student_t(4,0,15), class = &quot;Intercept&quot;)), # silent = 2, # refresh = 0, # backend = &quot;cmdstanr&quot;) # # b_CSI_TY_an2[i] &lt;- fixef(m_an2_TY_eigen_rand)[2,1] # b_rank_an2_TY[i] &lt;- fixef(m_an2_TY_eigen_rand)[3,1] # } ## 保存 # saveRDS(b_CSI_TY_an2, &quot;data/b_CSI_TY_an2.rds&quot;) # saveRDS(b_rank_an2_TY, &quot;data/b_rank_an2_TY.rds&quot;) ## 読み込み b_CSI_TY_an2 &lt;- readRDS(&quot;data/b_CSI_TY_an2.rds&quot;) b_rank_an2_TY &lt;- readRDS(&quot;data/b_rank_an2_TY.rds&quot;) 8.6.2.2.1.2 結果の確認 結果の表を作成します。 summary_an2_TY_eigen &lt;- summary(m_an2_TY_eigen) model_parameters(m_an2_TY_eigen, ci = 0.95,dispersion = TRUE, centrality = &quot;median&quot;, ci_method = &quot;eti&quot;) %&gt;% filter(Parameter != &quot;phi&quot;) %&gt;% data.frame() %&gt;% dplyr::select(1, 3,4, 9) %&gt;% mutate(&quot;Bulk ESS&quot; = summary_an2_TY_eigen$fixed$Bulk_ESS, &quot;Tail ESS&quot; = summary_an2_TY_eigen$fixed$Tail_ESS) %&gt;% mutate(`P left` = c(NA, mean(fixef(m_an2_TY_eigen)[2,1] &lt; b_CSI_TY_an2), mean(fixef(m_an2_TY_eigen)[3,1] &lt; b_rank_an2_TY))) %&gt;% mutate(`P right` = c(NA, mean(fixef(m_an2_TY_eigen)[2,1] &gt; b_CSI_TY_an2), mean(fixef(m_an2_TY_eigen)[3,1] &gt; b_rank_an2_TY))) %&gt;% select(1, 2, 3, 7, 8, everything()) %&gt;% mutate(Parameter = str_replace_all(Parameter, c(&quot;b_Intercept&quot;=&quot;Intercept&quot;, &quot;b_CSI_TY&quot; = &quot;CSI with TY&quot;, &quot;b_no_kin&quot; = &quot;No. of kin females in network&quot;, &quot;b_rank&quot; = &quot;Ordinal rank&quot;))) %&gt;% rename(&quot;Explanatory variables&quot; = &quot;Parameter&quot;) %&gt;% mutate(across(where(is.numeric), ~sprintf(&quot;%.2f&quot;, .))) -&gt; table_an2_TY_eigen table_an2_TY_eigen write_csv(table_an2_TY_eigen, &quot;tables/table_an2_TY_eigen.csv&quot;) 8.6.2.2.1.3 結果の作図 最後に結果を作図します。 pred_an2_TY_eigen &lt;- predict_response(m_an2_TY_eigen, terms = &quot;CSI_TY[0:4, by = 0.1]&quot;) %&gt;% data.frame() glmdata_an2_TY %&gt;% ggplot(aes(x = CSI_TY, y = eigen)) + geom_line(data = pred_an2_TY_eigen, aes(x = x, y = predicted)) + geom_ribbon(data = pred_an2_TY_eigen, aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high), alpha = 0.2) + geom_point(shape = 1, size = 3) + theme_bw(base_size = 12) + labs(x = &quot;CSI with *TY*&quot;, y = &quot;Eigenvector centrality&quot;, title = &quot;Network when *TY* was present (MS18 + MS19)&quot;) + theme(aspect.ratio = 1, text = element_text(family = &quot;Times New Roman&quot;), plot.title = element_markdown(family = &quot;Times New Roman&quot;, size = 10), axis.title.x = element_markdown()) -&gt; p_an2_TY_eigen p_an2_TY_eigen ggsave(&quot;figures/p_an2_TY_eigen.png&quot;, p_an2_TY_eigen, width = 100, height = 100, units = &quot;mm&quot;, dpi = 1000) 8.6.2.2.2 ITがいる日 8.6.2.2.2.1 モデリング まず、実際のネットワークを用いてGLMを実行します。 ###### モデリング まず、実際のネットワークを用いてGLMを実行します。 ## データの作成 ### 血縁個体数の算出 no_kin_an2_IT &lt;- tidyr::crossing(femaleID = metrics_an2_IT$ID, femaleID2 = metrics_an2_IT$ID) %&gt;% filter(!femaleID %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;), !femaleID2 %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;)) %&gt;% left_join(kin) %&gt;% drop_na(kin) %&gt;% group_by(femaleID) %&gt;% summarise(no_kin = sum(kin &gt;= 0.0625)) %&gt;% ungroup() ### データの整形と結合 glmdata_an2_IT &lt;- metrics_all_IT %&gt;% filter(study_period == &quot;MS20&quot;) %&gt;% arrange(rank) %&gt;% mutate(rank = 1:n()) %&gt;% select(ID, eigen, rank, CSI_IT) %&gt;% left_join(no_kin_an2_IT, by = c(&quot;ID&quot; = &quot;femaleID&quot;)) ## モデルの実行 m_an2_IT_eigen &lt;- brm(data = glmdata_an2_IT, formula = eigen ~ CSI_IT + rank, family = zero_one_inflated_beta(), prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), prior(student_t(4,0,15), class = &quot;Intercept&quot;)), silent = 2, refresh = 0, backend = &quot;cmdstanr&quot;, file = &quot;model/m_an2_IT_eigen&quot;) 結果は以下の通りです。 model_parameters(m_an2_IT_eigen) 続いて、500回ノードラベルパーミュテーションを行い、それぞれの係数を取得します。 # b_CSI_IT_an2 &lt;- rep(0, 500) # b_rank_an2_IT &lt;- rep(0, 500) # # set.seed(123) # pb = txtProgressBar(min = 1, max = 500, style = 3) # # for(i in 1:500){ # setTxtProgressBar(pb, i) # random_net_an2_IT &lt;- rmperm(mat_RG_an2_IT) # colnames(random_net_an2_IT) &lt;- colnames(mat_RG_an2_IT) # rownames(random_net_an2_IT) &lt;- rownames(mat_RG_an2_IT) # # ID_an2_IT_eigen_rand &lt;- met.eigen(random_net_an2_IT, # binary = FALSE, # sym = TRUE, # df = glmdata_an2_IT %&gt;% select(-eigen), # dfid = 1) %&gt;% # filter(!ID %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;)) # # m_an2_IT_eigen_rand &lt;- brm(data = ID_an2_IT_eigen_rand, # formula = eigen ~ CSI_IT + rank, # family = zero_one_inflated_beta(), # prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), # prior(student_t(4,0,15), class = &quot;Intercept&quot;)), # silent = 2, # refresh = 0, # backend = &quot;cmdstanr&quot;) # # b_CSI_IT_an2[i] &lt;- fixef(m_an2_IT_eigen_rand)[2,1] # b_rank_an2_IT[i] &lt;- fixef(m_an2_IT_eigen_rand)[3,1] # } ## 保存 # saveRDS(b_CSI_IT_an2, &quot;data/b_CSI_IT_an2.rds&quot;) # saveRDS(b_rank_an2_IT, &quot;data/b_rank_an2_IT.rds&quot;) ## 読み込み b_CSI_IT_an2 &lt;- readRDS(&quot;data/b_CSI_IT_an2.rds&quot;) b_rank_an2_IT &lt;- readRDS(&quot;data/b_rank_an2_IT.rds&quot;) 8.6.2.2.2.2 結果の確認 結果の表を作成します。 summary_an2_IT_eigen &lt;- summary(m_an2_IT_eigen) model_parameters(m_an2_IT_eigen, ci = 0.95,dispersion = TRUE, centrality = &quot;median&quot;, ci_method = &quot;eti&quot;) %&gt;% filter(Parameter != &quot;phi&quot;) %&gt;% data.frame() %&gt;% dplyr::select(1, 3,4, 9) %&gt;% mutate(&quot;Bulk ESS&quot; = summary_an2_IT_eigen$fixed$Bulk_ESS, &quot;Tail ESS&quot; = summary_an2_IT_eigen$fixed$Tail_ESS) %&gt;% mutate(`P left` = c(NA, mean(fixef(m_an2_IT_eigen)[2,1] &lt; b_CSI_IT_an2), mean(fixef(m_an2_IT_eigen)[3,1] &lt; b_rank_an2_IT))) %&gt;% mutate(`P right` = c(NA, mean(fixef(m_an2_IT_eigen)[2,1] &gt; b_CSI_IT_an2), mean(fixef(m_an2_IT_eigen)[3,1] &gt; b_rank_an2_IT))) %&gt;% select(1, 2, 3, 7, 8, everything()) %&gt;% mutate(Parameter = str_replace_all(Parameter, c(&quot;b_Intercept&quot;=&quot;Intercept&quot;, &quot;b_CSI_IT&quot; = &quot;CSI with IT&quot;, &quot;b_no_kin&quot; = &quot;No. of kin females in network&quot;, &quot;b_rank&quot; = &quot;Ordinal rank&quot;))) %&gt;% rename(&quot;Explanatory variables&quot; = &quot;Parameter&quot;) %&gt;% mutate(across(where(is.numeric), ~sprintf(&quot;%.2f&quot;, .))) -&gt; table_an2_IT_eigen table_an2_IT_eigen write_csv(table_an2_IT_eigen, &quot;tables/table_an2_IT_eigen.csv&quot;) 8.6.2.2.2.3 結果の作図 最後に結果を作図します。 pred_an2_IT_eigen &lt;- predict_response(m_an2_IT_eigen, terms = &quot;CSI_IT[0:4, by = 0.1]&quot;) %&gt;% data.frame() glmdata_an2_IT %&gt;% ggplot(aes(x = CSI_IT, y = eigen)) + geom_line(data = pred_an2_IT_eigen, aes(x = x, y = predicted)) + geom_ribbon(data = pred_an2_IT_eigen, aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high), alpha = 0.2) + geom_point(shape = 1, size = 3) + theme_bw(base_size = 12) + labs(x = &quot;CSI with *IT*&quot;, y = &quot;Eigenvector centraliIT&quot;, title = &quot;Network when *IT* was present (MS18 + MS19)&quot;) + theme(aspect.ratio = 1, text = element_text(family = &quot;Times New Roman&quot;), plot.title = element_markdown(family = &quot;Times New Roman&quot;, size = 10), axis.title.x = element_markdown()) -&gt; p_an2_IT_eigen p_an2_IT_eigen ggsave(&quot;figures/p_an2_IT_eigen.png&quot;, p_an2_IT_eigen, width = 100, height = 100, units = &quot;mm&quot;, dpi = 1000) 8.6.2.3 非交尾期 8.6.2.3.1 TYがいる日 8.6.2.3.1.1 モデリング まず、実際のネットワークを用いてGLMを実行します。 ## データの作成 ### 血縁個体数の算出 no_kin_nm_TY &lt;- tidyr::crossing(femaleID = metrics_nm_TY$ID, femaleID2 = metrics_nm_TY$ID) %&gt;% filter(!femaleID %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;), !femaleID2 %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;)) %&gt;% left_join(kin) %&gt;% drop_na(kin) %&gt;% group_by(femaleID) %&gt;% summarise(no_kin = sum(kin &gt;= 0.0625)) %&gt;% ungroup() ### データの整形と結合 glmdata_nm_TY &lt;- metrics_all_TY %&gt;% filter(study_period == &quot;NMS&quot;) %&gt;% arrange(rank) %&gt;% mutate(rank = 1:n()) %&gt;% select(ID, eigen, rank, CSI_TY) %&gt;% left_join(no_kin_nm_TY, by = c(&quot;ID&quot; = &quot;femaleID&quot;)) ## モデルの実行 m_nm_TY_eigen &lt;- brm(data = glmdata_nm_TY, formula = eigen ~ CSI_TY + no_kin + rank, family = zero_one_inflated_beta(), prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), prior(student_t(4,0,15), class = &quot;Intercept&quot;)), silent = 2, refresh = 0, backend = &quot;cmdstanr&quot;, file = &quot;model/m_nm_TY_eigen&quot;) 結果は以下の通りです。 model_parameters(m_nm_TY_eigen) 続いて、500回ノードラベルパーミュテーションを行い、それぞれの係数を取得します。 # b_CSI_TY_nm &lt;- rep(0, 500) # b_no_kin_nm_TY &lt;- rep(0, 500) # b_rank_nm_TY &lt;- rep(0, 500) # # set.seed(123) # pb = txtProgressBar(min = 1, max = 500, style = 3) # # for(i in 1:500){ # setTxtProgressBar(pb, i) # random_net_nm_TY &lt;- rmperm(mat_RG_nm_TY) # colnames(random_net_nm_TY) &lt;- colnames(mat_RG_nm_TY) # rownames(random_net_nm_TY) &lt;- rownames(mat_RG_nm_TY) # # ID_nm_TY_eigen_rand &lt;- met.eigen(random_net_nm_TY, # binary = FALSE, # sym = TRUE, # df = glmdata_nm_TY %&gt;% select(-eigen), # dfid = 1) %&gt;% # filter(!ID %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;)) # # m_nm_TY_eigen_rand &lt;- brm(data = ID_nm_TY_eigen_rand, # formula = eigen ~ CSI_TY + no_kin + rank, # family = zero_one_inflated_beta(), # prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), # prior(student_t(4,0,15), class = &quot;Intercept&quot;)), # silent = 2, # refresh = 0, # backend = &quot;cmdstanr&quot;) # # b_CSI_TY_nm[i] &lt;- fixef(m_nm_TY_eigen_rand)[2,1] # b_no_kin_nm_TY[i] &lt;- fixef(m_nm_TY_eigen_rand)[3,1] # b_rank_nm_TY[i] &lt;- fixef(m_nm_TY_eigen_rand)[4,1] # } ## 保存 # saveRDS(b_CSI_TY_nm, &quot;data/b_CSI_TY_nm.rds&quot;) # saveRDS(b_no_kin_nm_TY, &quot;data/b_no_kin_nm_TY.rds&quot;) # saveRDS(b_rank_nm_TY, &quot;data/b_rank_nm_TY.rds&quot;) ## 読み込み b_CSI_TY_nm &lt;- readRDS(&quot;data/b_CSI_TY_nm.rds&quot;) b_no_kin_nm_TY &lt;- readRDS(&quot;data/b_no_kin_nm_TY.rds&quot;) b_rank_nm_TY &lt;- readRDS(&quot;data/b_rank_nm_TY.rds&quot;) 8.6.2.3.1.2 結果の確認 結果の表を作成します。 summary_nm_TY_eigen &lt;- summary(m_nm_TY_eigen) model_parameters(m_nm_TY_eigen, ci = 0.95,dispersion = TRUE, centrality = &quot;median&quot;, ci_method = &quot;eti&quot;) %&gt;% filter(Parameter != &quot;phi&quot;) %&gt;% data.frame() %&gt;% dplyr::select(1, 3,4, 9) %&gt;% mutate(&quot;Bulk ESS&quot; = summary_nm_TY_eigen$fixed$Bulk_ESS, &quot;Tail ESS&quot; = summary_nm_TY_eigen$fixed$Tail_ESS) %&gt;% mutate(`P left` = c(NA, mean(fixef(m_nm_TY_eigen)[2,1] &lt; b_CSI_TY_nm), mean(fixef(m_nm_TY_eigen)[3,1] &lt; b_no_kin_nm_TY), mean(fixef(m_nm_TY_eigen)[4,1] &lt; b_rank_nm_TY))) %&gt;% mutate(`P right` = c(NA, mean(fixef(m_nm_TY_eigen)[2,1] &gt; b_CSI_TY_nm), mean(fixef(m_nm_TY_eigen)[3,1] &gt; b_no_kin_nm_TY), mean(fixef(m_nm_TY_eigen)[4,1] &gt; b_rank_nm_TY))) %&gt;% select(1, 2, 3, 7, 8, everything()) %&gt;% mutate(Parameter = str_replace_all(Parameter, c(&quot;b_Intercept&quot;=&quot;Intercept&quot;, &quot;b_CSI_TY&quot; = &quot;CSI with TY&quot;, &quot;b_no_kin&quot; = &quot;No. of kin females in network&quot;, &quot;b_rank&quot; = &quot;Ordinal rank&quot;))) %&gt;% rename(&quot;Explanatory variables&quot; = &quot;Parameter&quot;) %&gt;% mutate(across(where(is.numeric), ~sprintf(&quot;%.2f&quot;, .))) -&gt; table_nm_TY_eigen table_nm_TY_eigen write_csv(table_nm_TY_eigen, &quot;tables/table_nm_TY_eigen.csv&quot;) 8.6.2.3.1.3 結果の作図 最後に結果を作図します。 pred_nm_TY_eigen &lt;- predict_response(m_nm_TY_eigen, terms = &quot;CSI_TY[0:5, by = 0.1]&quot;) %&gt;% data.frame() glmdata_nm_TY %&gt;% ggplot(aes(x = CSI_TY, y = eigen)) + geom_line(data = pred_nm_TY_eigen, aes(x = x, y = predicted)) + geom_ribbon(data = pred_nm_TY_eigen, aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high), alpha = 0.2) + geom_point(shape = 1, size = 3) + theme_bw(base_size = 12) + labs(x = &quot;CSI with *TY*&quot;, y = &quot;Eigenvector centrality&quot;, title = &quot;Network when *TY* was present (MS18 + MS19)&quot;) + theme(aspect.ratio = 1, text = element_text(family = &quot;Times New Roman&quot;), plot.title = element_markdown(family = &quot;Times New Roman&quot;, size = 10), axis.title.x = element_markdown()) -&gt; p_nm_TY_eigen p_nm_TY_eigen ggsave(&quot;figures/p_nm_TY_eigen.png&quot;, p_nm_TY_eigen, width = 100, height = 100, units = &quot;mm&quot;, dpi = 1000) 8.6.2.3.2 ITがいる日 8.6.2.3.2.1 モデリング まず、実際のネットワークを用いてGLMを実行します。 ###### モデリング まず、実際のネットワークを用いてGLMを実行します。 ## データの作成 ### 血縁個体数の算出 no_kin_nm_IT &lt;- tidyr::crossing(femaleID = metrics_nm_IT$ID, femaleID2 = metrics_nm_IT$ID) %&gt;% filter(!femaleID %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;), !femaleID2 %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;)) %&gt;% left_join(kin) %&gt;% drop_na(kin) %&gt;% group_by(femaleID) %&gt;% summarise(no_kin = sum(kin &gt;= 0.0625)) %&gt;% ungroup() ### データの整形と結合 glmdata_nm_IT &lt;- metrics_all_IT %&gt;% filter(study_period == &quot;NMS&quot;) %&gt;% arrange(rank) %&gt;% mutate(rank = 1:n()) %&gt;% select(ID, eigen, rank, CSI_IT) %&gt;% left_join(no_kin_nm_IT, by = c(&quot;ID&quot; = &quot;femaleID&quot;)) ## モデルの実行 m_nm_IT_eigen &lt;- brm(data = glmdata_nm_IT, formula = eigen ~ CSI_IT + no_kin + rank, family = zero_one_inflated_beta(), prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), prior(student_t(4,0,15), class = &quot;Intercept&quot;)), silent = 2, refresh = 0, backend = &quot;cmdstanr&quot;, file = &quot;model/m_nm_IT_eigen&quot;) 結果は以下の通りです。 model_parameters(m_nm_IT_eigen) 続いて、500回ノードラベルパーミュテーションを行い、それぞれの係数を取得します。 # b_CSI_IT_nm &lt;- rep(0, 500) # b_no_kin_nm_IT &lt;- rep(0, 500) # b_rank_nm_IT &lt;- rep(0, 500) # # set.seed(123) # pb = txtProgressBar(min = 1, max = 500, style = 3) # # for(i in 1:500){ # setTxtProgressBar(pb, i) # random_net_nm_IT &lt;- rmperm(mat_RG_nm_IT) # colnames(random_net_nm_IT) &lt;- colnames(mat_RG_nm_IT) # rownames(random_net_nm_IT) &lt;- rownames(mat_RG_nm_IT) # # ID_nm_IT_eigen_rand &lt;- met.eigen(random_net_nm_IT, # binary = FALSE, # sym = TRUE, # df = glmdata_nm_IT %&gt;% select(-eigen), # dfid = 1) %&gt;% # filter(!ID %in% c(&quot;TY&quot;, &quot;IT&quot;, &quot;KR&quot;, &quot;LK&quot;)) # # m_nm_IT_eigen_rand &lt;- brm(data = ID_nm_IT_eigen_rand, # formula = eigen ~ CSI_IT + no_kin + rank, # family = zero_one_inflated_beta(), # prior = c(prior(student_t(4,0,15), class = &quot;b&quot;), # prior(student_t(4,0,15), class = &quot;Intercept&quot;)), # silent = 2, # refresh = 0, # backend = &quot;cmdstanr&quot;) # # b_CSI_IT_nm[i] &lt;- fixef(m_nm_IT_eigen_rand)[2,1] # b_no_kin_nm_IT[i] &lt;- fixef(m_nm_IT_eigen_rand)[3,1] # b_rank_nm_IT[i] &lt;- fixef(m_nm_IT_eigen_rand)[4,1] # } ## 保存 # saveRDS(b_CSI_IT_nm, &quot;data/b_CSI_IT_nm.rds&quot;) # saveRDS(b_no_kin_nm_IT, &quot;data/b_no_kin_nm_IT.rds&quot;) # saveRDS(b_rank_nm_IT, &quot;data/b_rank_nm_IT.rds&quot;) ## 読み込み b_CSI_IT_nm &lt;- readRDS(&quot;data/b_CSI_IT_nm.rds&quot;) b_no_kin_nm_IT &lt;- readRDS(&quot;data/b_no_kin_nm_IT.rds&quot;) b_rank_nm_IT &lt;- readRDS(&quot;data/b_rank_nm_IT.rds&quot;) 8.6.2.3.2.2 結果の確認 結果の表を作成します。 summary_nm_IT_eigen &lt;- summary(m_nm_IT_eigen) model_parameters(m_nm_IT_eigen, ci = 0.95,dispersion = TRUE, centrality = &quot;median&quot;, ci_method = &quot;eti&quot;) %&gt;% filter(Parameter != &quot;phi&quot;) %&gt;% data.frame() %&gt;% dplyr::select(1, 3,4, 9) %&gt;% mutate(&quot;Bulk ESS&quot; = summary_nm_IT_eigen$fixed$Bulk_ESS, &quot;Tail ESS&quot; = summary_nm_IT_eigen$fixed$Tail_ESS) %&gt;% mutate(`P left` = c(NA, mean(fixef(m_nm_IT_eigen)[2,1] &lt; b_CSI_IT_nm), mean(fixef(m_nm_IT_eigen)[3,1] &lt; b_no_kin_nm_IT), mean(fixef(m_nm_IT_eigen)[4,1] &lt; b_rank_nm_IT))) %&gt;% mutate(`P right` = c(NA, mean(fixef(m_nm_IT_eigen)[2,1] &gt; b_CSI_IT_nm), mean(fixef(m_nm_IT_eigen)[3,1] &gt; b_no_kin_nm_IT), mean(fixef(m_nm_IT_eigen)[4,1] &gt; b_rank_nm_IT))) %&gt;% select(1, 2, 3, 7, 8, everything()) %&gt;% mutate(Parameter = str_replace_all(Parameter, c(&quot;b_Intercept&quot;=&quot;Intercept&quot;, &quot;b_CSI_IT&quot; = &quot;CSI with IT&quot;, &quot;b_no_kin&quot; = &quot;No. of kin females in network&quot;, &quot;b_rank&quot; = &quot;Ordinal rank&quot;))) %&gt;% rename(&quot;Explanatory variables&quot; = &quot;Parameter&quot;) %&gt;% mutate(across(where(is.numeric), ~sprintf(&quot;%.2f&quot;, .))) -&gt; table_nm_IT_eigen table_nm_IT_eigen write_csv(table_nm_IT_eigen, &quot;tables/table_nm_IT_eigen.csv&quot;) 8.6.2.3.2.3 結果の作図 最後に結果を作図します。 pred_nm_IT_eigen &lt;- predict_response(m_nm_IT_eigen, terms = &quot;CSI_IT[0:4, by = 0.1]&quot;) %&gt;% data.frame() glmdata_nm_IT %&gt;% ggplot(aes(x = CSI_IT, y = eigen)) + geom_line(data = pred_nm_IT_eigen, aes(x = x, y = predicted)) + geom_ribbon(data = pred_nm_IT_eigen, aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high), alpha = 0.2) + geom_point(shape = 1, size = 3) + theme_bw(base_size = 12) + labs(x = &quot;CSI with *IT*&quot;, y = &quot;Eigenvector centraliIT&quot;, title = &quot;Network when *IT* was present (NMS)&quot;) + theme(aspect.ratio = 1, text = element_text(family = &quot;Times New Roman&quot;), plot.title = element_markdown(family = &quot;Times New Roman&quot;, size = 10), axis.title.x = element_markdown()) -&gt; p_nm_IT_eigen p_nm_IT_eigen ggsave(&quot;figures/p_nm_IT_eigen.png&quot;, p_nm_IT_eigen, width = 100, height = 100, units = &quot;mm&quot;, dpi = 1000) "],["sessioninfo.html", "実行環境", " 実行環境 sessionInfo() ## R version 4.4.0 (2024-04-24 ucrt) ## Platform: x86_64-w64-mingw32/x64 ## Running under: Windows 11 x64 (build 22631) ## ## Matrix products: default ## ## ## locale: ## [1] LC_COLLATE=Japanese_Japan.utf8 LC_CTYPE=Japanese_Japan.utf8 ## [3] LC_MONETARY=Japanese_Japan.utf8 LC_NUMERIC=C ## [5] LC_TIME=Japanese_Japan.utf8 ## ## time zone: Asia/Tokyo ## tzcode source: internal ## ## attached base packages: ## [1] parallel stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] glmmTMB_1.1.9 systemfonts_1.1.0 ## [3] extrafont_0.19 ggpattern_1.1.1 ## [5] ggh4x_0.2.8 ggsignif_0.6.4 ## [7] lemon_0.4.9 ggsci_3.2.0 ## [9] kableExtra_1.4.0 patchwork_1.2.0 ## [11] ggrepel_0.9.6 flextable_0.9.6 ## [13] GGally_2.2.1 ggnewscale_0.4.10 ## [15] viridis_0.6.5 viridisLite_0.4.2 ## [17] bayesplot_1.11.1 plotly_4.10.4 ## [19] ggbeeswarm_0.7.2 ggforce_0.4.2 ## [21] ggtext_0.1.2 ggraph_2.2.1 ## [23] tidygraph_1.3.1 igraph_2.0.3 ## [25] vegan_2.6-6.1 lattice_0.22-6 ## [27] permute_0.9-7 aninet_0.2.0.0 ## [29] asnipe_1.1.17 ANTs_0.0.16 ## [31] sna_2.7-2 network_1.18.2 ## [33] statnet.common_4.9.0 DHARMa.helpers_0.0.0.9000 ## [35] DHARMa_0.4.6 ggeffects_1.6.0 ## [37] cmdstanr_0.8.0 rstanarm_2.32.1 ## [39] rstan_2.32.6 StanHeaders_2.32.8 ## [41] rethinking_2.13.2 brms_2.21.0 ## [43] Rcpp_1.0.12 emmeans_1.10.2 ## [45] scales_1.3.0 DT_0.33 ## [47] see_0.8.4 report_0.5.8 ## [49] parameters_0.22.0 performance_0.12.0 ## [51] modelbased_0.8.8 insight_0.20.1 ## [53] effectsize_0.8.9 datawizard_0.11.0 ## [55] correlation_0.8.5 bayestestR_0.13.2 ## [57] easystats_0.7.2 knitr_1.48 ## [59] readxl_1.4.3 lubridate_1.9.3 ## [61] forcats_1.0.0 stringr_1.5.1 ## [63] dplyr_1.1.4 purrr_1.0.2 ## [65] readr_2.1.5 tidyr_1.3.1 ## [67] tibble_3.2.1 ggplot2_3.5.1 ## [69] tidyverse_2.0.0 ## ## loaded via a namespace (and not attached): ## [1] matrixStats_1.3.0 httr_1.4.7 RColorBrewer_1.1-3 ## [4] numDeriv_2016.8-1.1 tools_4.4.0 backports_1.5.0 ## [7] sjlabelled_1.2.0 utf8_1.2.4 R6_2.5.1 ## [10] lazyeval_0.2.2 mgcv_1.9-1 withr_3.0.1 ## [13] Brobdingnag_1.2-9 gridExtra_2.3 archive_1.1.8 ## [16] cli_3.6.2 textshaping_0.4.0 shinyjs_2.1.0 ## [19] officer_0.6.6 sandwich_3.1-0 labeling_0.4.3 ## [22] sass_0.4.9 mvtnorm_1.2-5 askpass_1.2.0 ## [25] QuickJSR_1.1.3 commonmark_1.9.2 gfonts_0.2.0 ## [28] svglite_2.1.3 rstudioapi_0.16.0 httpcode_0.3.0 ## [31] generics_0.1.3 shape_1.4.6.1 vroom_1.6.5 ## [34] gtools_3.9.5 crosstalk_1.2.1 distributional_0.4.0 ## [37] zip_2.3.1 inline_0.3.19 loo_2.7.0 ## [40] Matrix_1.7-0 fansi_1.0.6 abind_1.4-8 ## [43] lifecycle_1.0.4 multcomp_1.4-25 yaml_2.3.8 ## [46] snakecase_0.11.1 grid_4.4.0 promises_1.3.0 ## [49] crayon_1.5.2 miniUI_0.1.1.1 haven_2.5.4 ## [52] pillar_1.9.0 boot_1.3-30 estimability_1.5.1 ## [55] shinystan_2.6.0 codetools_0.2-20 glue_1.7.0 ## [58] V8_4.4.2 fontLiberation_0.1.0 data.table_1.15.4 ## [61] vctrs_0.6.5 cellranger_1.1.0 gtable_0.3.5 ## [64] cachem_1.1.0 xfun_0.44 mime_0.12 ## [67] coda_0.19-4.1 survival_3.6-4 Kendall_2.2.1 ## [70] shinythemes_1.2.0 TH.data_1.1-2 nlme_3.1-164 ## [73] xts_0.13.2 bit64_4.0.5 fontquiver_0.2.1 ## [76] threejs_0.3.3 tensorA_0.36.2.1 TMB_1.9.11 ## [79] bslib_0.7.0 vipor_0.4.7 colorspace_2.1-0 ## [82] tidyselect_1.2.1 processx_3.8.4 bit_4.0.5 ## [85] extrafontdb_1.0 compiler_4.4.0 curl_5.2.1 ## [88] xml2_1.3.6 fontBitstreamVera_0.1.1 colourpicker_1.3.0 ## [91] posterior_1.5.0 bookdown_0.39 checkmate_2.3.1 ## [94] dygraphs_1.1.1.6 digest_0.6.35 minqa_1.2.7 ## [97] rmarkdown_2.27 htmltools_0.5.8.1 pkgconfig_2.0.3 ## [100] base64enc_0.1-3 lme4_1.1-35.3 highr_0.11 ## [103] fastmap_1.2.0 rlang_1.1.3 htmlwidgets_1.6.4 ## [106] shiny_1.8.1.1 farver_2.1.2 jquerylib_0.1.4 ## [109] zoo_1.8-12 jsonlite_1.8.8 magrittr_2.0.3 ## [112] munsell_0.5.1 gdtools_0.3.7 stringi_1.8.4 ## [115] MASS_7.3-60.2 plyr_1.8.9 pkgbuild_1.4.4 ## [118] ggstats_0.6.0 graphlayouts_1.1.1 splines_4.4.0 ## [121] gridtext_0.1.5 hms_1.1.3 ps_1.7.6 ## [124] uuid_1.2-0 markdown_1.13 reshape2_1.4.4 ## [127] stats4_4.4.0 rstantools_2.4.0 crul_1.4.2 ## [130] evaluate_1.0.0 RcppParallel_5.1.7 nloptr_2.0.3 ## [133] tzdb_0.4.0 tweenr_2.0.3 httpuv_1.6.15 ## [136] Rttf2pt1_1.3.12 openssl_2.2.0 polyclip_1.10-6 ## [139] xtable_1.8-4 later_1.3.2 ragg_1.3.2 ## [142] memoise_2.0.1 beeswarm_0.4.0 cluster_2.1.6 ## [145] timechange_0.3.0 bridgesampling_1.1-2 References Chang, W. (2018). R graphics cookbook: Practical recipes for visualizing data. “O’Reilly Media, Inc.” Gabry, J., &amp; Mahr, T. (2022). Bayesplot: Plotting for bayesian models. https://mc-stan.org/bayesplot Hartig, F. (2022). DHARMa: Residual diagnostics for hierarchical (multi-level / mixed) regression models. https://CRAN.R-project.org/package=DHARMa Rodríguez-Sánchez, F. (2023). DHARMa.helpers: Helper functions to check models not (yet) directly supported by DHARMa. Wickham, H., &amp; Grolemund, G. (2016). R for data science: Import, tidy, transform, visualize, and model data. “O’Reilly Media, Inc.” Yamaguchi, T., &amp; Kazahari, N. (2022). Fission–fusion dynamics in a wild group of japanese macaques (macaca fuscata) on kinkazan island caused by the repeated separation of an alpha male being followed by females. Primates, 63(6), 575–582. 松村優哉., 湯谷啓明., 紀ノ定保礼., &amp; 前田和. (2021). RユーザのためのRstudio[実践]入門 tidyverseによるモダンな分析フローの世界 改訂2版. 技術評論社. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
